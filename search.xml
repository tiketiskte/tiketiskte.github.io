<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>nowcoder_入门课1</title>
    <url>/2020/05/20/nowcoder-%E5%85%A5%E9%97%A8%E8%AF%BE1/</url>
    <content><![CDATA[<p>枚举 贪心 暴力 前缀和</p>
<a id="more"></a>
<h3 id="POJ1753-Flip-Game"><a href="#POJ1753-Flip-Game" class="headerlink" title="POJ1753: Flip Game"></a>POJ1753: Flip Game</h3><p>思路:</p>
<p>数据规模是$4 * 4$的，我们可以直接用一个char的$Map$来存储状态。</p>
<p>判断终点是所有的单元格的状态都相同 我们可以用一个$temp$ 然后遍历 进行判断。</p>
<p><strong>注：翻转操作的时候 可能是$3$或$5$次相邻的翻转操作 我们最好是将其写成$flip$函数调用。</strong></p>
<p>对$Map$从起点开始枚举每一个单元格翻转之后判断状态 类似<strong>DFS</strong></p>
<p>注意回溯处理 如果反转之后要回溯一下  </p>
<p>不翻转 即可DFS下一个单元格。<strong>详见代码</strong></p>
<p>时间复杂度：</p>
<script type="math/tex; mode=display">
O(2^N * N * M)\\
每一个单元格有2^N种状态</script><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Map[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> ans = INF;<span class="comment">//get_min set_max</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = Map[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Map[i][j] != temp) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vertical is x and horizontal is y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Map[x][y] == <span class="string">'w'</span>) &#123;<span class="comment">//flip self</span></span><br><span class="line">        Map[x][y] = <span class="string">'b'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Map[x][y] == <span class="string">'b'</span>)&#123;</span><br><span class="line">        Map[x][y] = <span class="string">'w'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Map[x - <span class="number">1</span>][y] == <span class="string">'w'</span>) &#123;<span class="comment">//flip up</span></span><br><span class="line">        Map[x - <span class="number">1</span>][y] = <span class="string">'b'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Map[x - <span class="number">1</span>][y] == <span class="string">'b'</span>) &#123;</span><br><span class="line">        Map[x - <span class="number">1</span>][y] = <span class="string">'w'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Map[x + <span class="number">1</span>][y] == <span class="string">'w'</span>) &#123;<span class="comment">//flip down</span></span><br><span class="line">        Map[x + <span class="number">1</span>][y] = <span class="string">'b'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Map[x + <span class="number">1</span>][y] == <span class="string">'b'</span>) &#123;</span><br><span class="line">        Map[x + <span class="number">1</span>][y] = <span class="string">'w'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Map[x][y - <span class="number">1</span>] == <span class="string">'w'</span>) &#123;<span class="comment">//flip left</span></span><br><span class="line">        Map[x][y - <span class="number">1</span>] = <span class="string">'b'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Map[x][y - <span class="number">1</span>] == <span class="string">'b'</span>) &#123;</span><br><span class="line">        Map[x][y - <span class="number">1</span>] = <span class="string">'w'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Map[x][y + <span class="number">1</span>] == <span class="string">'w'</span>) &#123;<span class="comment">//flip right</span></span><br><span class="line">        Map[x][y + <span class="number">1</span>] = <span class="string">'b'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Map[x][y + <span class="number">1</span>] == <span class="string">'b'</span>) &#123;</span><br><span class="line">        Map[x][y + <span class="number">1</span>] = <span class="string">'w'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; ans) &#123;<span class="comment">//min_step</span></span><br><span class="line">            ans = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">5</span> || y == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flip(x, y);<span class="comment">//flip</span></span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">4</span>) &#123;</span><br><span class="line">        DFS(x + <span class="number">1</span>, <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DFS(x, y + <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flip(x, y);<span class="comment">//flip_back</span></span><br><span class="line">    <span class="comment">//not flip</span></span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">4</span>) &#123;</span><br><span class="line">        DFS(x + <span class="number">1</span>, <span class="number">1</span>, cnt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DFS(x, y + <span class="number">1</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++) &#123;</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; Map[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   DFS(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="comment">//cout &lt;&lt; "ans:" &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">   <span class="keyword">if</span>(ans != INF) &#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="POJ3061-Subsequence"><a href="#POJ3061-Subsequence" class="headerlink" title="POJ3061: Subsequence"></a>POJ3061: Subsequence</h3><p>思路:</p>
<p>给一个·长度为$n$的正整数序列，找出最短的子序列使其和大于等于$S$。</p>
<p>方法：双指针$two pointer$</p>
<p>我们用两个指针$i,j$来表示当前下边位置，$sum$用来表示当前的和。</p>
<p>因为都是正整数 所以是越加越大的 我们可以固定左指针$l$不动来移动右指针$r$，并加到$sum$直到$&gt;=$$S$。然后我们右指针$r$可以固定不动了，以为要找最短其均为正整数。我们移动左指针$l$,即：</p>
<script type="math/tex; mode=display">
sum -= a[l];//缩小区间范围\\
l++;//右移</script><p>然后看$sum$和$S$的关系，如果满足更新$ans$，如果不满足，则继续移动右指针$r$。</p>
<p><strong>复杂度：</strong></p>
<p><strong>左/右</strong>指针最多$n$次且独立不相关 ，操作次数满足加法原理 即$2n$次 </p>
<p>时间复杂度：</p>
<script type="math/tex; mode=display">
T(n) = O(n)</script><p><strong><em>注：</em></strong>当需要查询的子区间某一个相关值时，可以采用<strong>双指针/尺取法</strong>。</p>
<p>尺取法大概分四步：</p>
<ul>
<li><strong>初始化做右端点</strong></li>
<li><strong>不断扩大右端点 直到满足条件</strong></li>
<li><strong>如果第二部中条件不满足则终止，否则更新结果</strong></li>
<li><strong>将左端点扩大1，然后回到第二步</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, N, S, a[maxn];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">   <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; S;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">       sum = <span class="number">0</span>, ans = INF;</span><br><span class="line">       <span class="keyword">while</span>(l &lt;= N) &#123;</span><br><span class="line">           <span class="keyword">while</span>(r &lt;= N &amp;&amp; sum &lt; S) &#123;</span><br><span class="line">               sum += a[r];</span><br><span class="line">               r++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(sum &gt;= S) &#123;</span><br><span class="line">               ans = <span class="built_in">min</span>(ans, r - l);<span class="comment">// get min</span></span><br><span class="line">           &#125;</span><br><span class="line">           sum -= a[l];</span><br><span class="line">           l++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(ans != INF) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NC24867-Selfish-Grazing"><a href="#NC24867-Selfish-Grazing" class="headerlink" title="NC24867: Selfish Grazing"></a>NC24867: Selfish Grazing</h3><p>思路:</p>
<p>给若干个区间，让你找这些区间内互不包含的最大区间数。</p>
<p><strong>套路题：贪心策略</strong></p>
<p>按照右端点进行升序排序 如果下一个区间的左端点大于上一个区间的右端点 证明不包含 $ans++$</p>
<p>用$now$来表示更新即可。</p>
<p>原因：很显然我总长度是固定的，一头牛的右端点越小给到后面牛可能吃到草的概率越大。也就是如果这个地方你不选这头牛，其他牛结束点一定比现在后，就算他起始点再好，也就和我选结束点前的方案数相同。甚至会让后面的牛选不了。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> l, r;</span><br><span class="line">   <span class="comment">/* data */</span></span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(a.r == b.r) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, ans, now;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">   now = <span class="number">-1</span>;<span class="comment">//注意初始值</span></span><br><span class="line">   ans = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i].l &gt;&gt; a[i].r;</span><br><span class="line">   &#125;</span><br><span class="line">   sort(a + <span class="number">1</span>, a + <span class="number">1</span> + N, cmp);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i].l &gt;= now) &#123;</span><br><span class="line">         now = a[i].r;</span><br><span class="line">         ans++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NC16649-校门外的树"><a href="#NC16649-校门外的树" class="headerlink" title="NC16649: 校门外的树"></a>NC16649: 校门外的树</h3><p>思路:</p>
<p>离散化 区间设置标记 扫一遍记录$ans$。</p>
<p><strong>差分做法待补充qwq</strong>……</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> L, M;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; M;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; i++) &#123;</span><br><span class="line">       a[i] = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt;= r; j++) &#123;</span><br><span class="line">            a[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(a[i] != <span class="number">0</span>) &#123;</span><br><span class="line">           ans++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NC16669-明明的随机数"><a href="#NC16669-明明的随机数" class="headerlink" title="NC16669:明明的随机数"></a>NC16669:明明的随机数</h3><p>思路:</p>
<ul>
<li><p>桶排序思想/离散化处理</p>
<p>打$flag$标记，如果有的话，标记为$1$，时候输出即可。</p>
</li>
<li><p>利用STL中的$set$ / $map$来处理 ，模拟即可。</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, cnt;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	IOS</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span>(a[x] == <span class="number">0</span>) &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="comment">//cout &lt;&lt; "###" &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">		a[x] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//思路2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, x;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">      s.insert(x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">for</span>(it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      <span class="comment">//printf("%d ", *it);</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NC20032-HNOI激光炸弹"><a href="#NC20032-HNOI激光炸弹" class="headerlink" title="NC20032: HNOI激光炸弹"></a>NC20032: HNOI激光炸弹</h3><p>思路:</p>
<p>给你一个边长为$r$的正方形，让你围成权值最大的部分。</p>
<p>我们可以考虑前缀和  考虑一下一维前缀和：</p>
<script type="math/tex; mode=display">
s[i] = \sum_{j = 1}^i{A[i]}</script><p>我们用$O(n)$的时间求出前缀和 后续查询部分和即可在$O(1)$的时间内完成。</p>
<script type="math/tex; mode=display">
sum[l, r] = \sum_{i = l}^r{A[i]}=s[r] - s[l - 1]</script><p>这个题涉及权值，我们可以考虑一下用二位前缀和来维护坐标为$i，j$的总权值。</p>
<p>二维前缀和:</p>
<script type="math/tex; mode=display">
s[i][j] = \sum_{a = 1}^i\sum_{b = 1}^j{A[a][b]}</script><script type="math/tex; mode=display">
s[i][j]：以(1, 1)为左上角，(i,j)为右下角的矩形的面积/权值</script><p>如图所示：</p>
<p><img src="/2020/05/20/nowcoder-%E5%85%A5%E9%97%A8%E8%AF%BE1/two_sum.jpg" alt></p>
<p>我们可以在$O(n ^ 2)$的时间内预处理出二维前缀和$S$。</p>
<p>下边我们只需要找边长为$r$的区域使得权值最大 </p>
<p>即：以$(i, j)$为右下角，边长为$r$的正方形区域的面积/权值。</p>
<script type="math/tex; mode=display">
\sum_{a = i - r + 1}^i\sum_{b = j - r + 1}^j \\= s[i][j] - s[i - r][j]- s[i][j - r] + s[i - r][j - r]</script><p><strong>细节</strong>：</p>
<ul>
<li><p>因为靠考虑前缀和 我们下标从$0$开始存储，可能会出现数组越界的错误 因此我们$x,j$都$+1$.</p>
</li>
<li><p>预处理前缀和时，可以缩小预处理的范围：</p>
<p>选取最小范围的正方形 这样才能保证寻找二维前缀和时初始访问位置有效</p>
<p>即$x = y = r$ 然后根据$x, y$选取 详见代码.</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, r;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> sum[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r;</span><br><span class="line">   <span class="keyword">int</span> m_x = r, m_y = r;<span class="comment">//设置边界值为r 缩小求前缀和范围</span></span><br><span class="line">   <span class="keyword">int</span> x, y, w;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">       x++, y++;</span><br><span class="line">       sum[x][y] = w;</span><br><span class="line">       m_x = <span class="built_in">max</span>(x, m_x);</span><br><span class="line">       m_y = <span class="built_in">max</span>(y, m_y);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m_x; i++) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m_y; j++) &#123;</span><br><span class="line">           sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + sum[i][j]; </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &lt;= m_x; i++) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = r; j &lt;= m_y; j++) &#123;<span class="comment">//找范围</span></span><br><span class="line">           ans = <span class="built_in">max</span>(ans, sum[i][j] - sum[i - r][j] - sum[i][j - r] + sum[i - r][j - r]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NC25136-切长条"><a href="#NC25136-切长条" class="headerlink" title="NC25136:切长条"></a>NC25136:切长条</h3><p>思路:</p>
<p><strong>贪心策略</strong>：</p>
<p>转换成求<strong>最大不相交区间数量</strong>的问题。</p>
<p>我们切的时候，尽可能的使要切的区间尽可能的大。</p>
<p>涉及左右多因素时，可以采用<strong>结构体/pair</strong>来处理。</p>
<p>因为我们找的时候 尽可能先找区间范围大的，这样在后续有可选择的余地。</p>
<p>上一个区间结束的越早 下一个区间就可以早开始。</p>
<p>于是按照区间的右端点进行升序排序，用一个变量$now$记录当前，判断下一个区间的左区间和$now$的关系。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组结构体操作</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">32000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.r == b.r) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">   <span class="keyword">int</span> x;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; a[i].l &gt;&gt; x;</span><br><span class="line">       a[i].r = a[i].l + x;</span><br><span class="line">   &#125;</span><br><span class="line">   sort(a + <span class="number">1</span>, a + <span class="number">1</span> + N, cmp);</span><br><span class="line">   <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(a[i].l &gt;= now) &#123;</span><br><span class="line">           ans++;</span><br><span class="line">           now = a[i].r;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pair操作</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">32000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, len;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second == b.second) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; pr[i].first &gt;&gt; len; </span><br><span class="line">       pr[i].second = pr[i].first + len;</span><br><span class="line">   &#125;</span><br><span class="line">   sort(pr + <span class="number">1</span>, pr + <span class="number">1</span> + n, cmp);</span><br><span class="line">   <span class="keyword">int</span> ans = <span class="number">0</span>, now = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(now &lt;= pr[i].first) &#123;</span><br><span class="line">           ans++;</span><br><span class="line">           now = pr[i].second;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NC16593-铺地毯"><a href="#NC16593-铺地毯" class="headerlink" title="NC16593:铺地毯"></a>NC16593:铺地毯</h3><p>思路:</p>
<p>从后向前找 因为答案让你找最上面的，考虑一下逆向思维，后来放的肯定在前边放的上边 </p>
<p>因此我们只需要从后往前判断有没有符合的区间包含这个点即可。二维平面 两个$if$判断一下。</p>
<p>然后如果有的话 输出然后$return 0;$即可，因为只让输出最上边的。</p>
<p>【同样可以打一个$flag$标记，然后判一下】</p>
<p><strong>注意：！！！</strong></p>
<p>该题空间给的是128MB，我们计算一下如果开二维数组，可能会有爆空间的风险……</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], g[maxn], k[maxn];</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; g[i] &gt;&gt; k[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">       <span class="keyword">if</span>(x &gt;= a[i] &amp;&amp; x &lt;= a[i] + g[i]) &#123;</span><br><span class="line">           <span class="keyword">if</span>(y &gt;= b[i] &amp;&amp; y &lt;= b[i] + k[i]) &#123;</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NC16640-纪念品分组"><a href="#NC16640-纪念品分组" class="headerlink" title="NC16640:纪念品分组"></a>NC16640:纪念品分组</h3><p>思路:</p>
<p>类似POJ3061:Subsequence的思路，采用双指针来解决。</p>
<p>排序 然后两个指针扫一遍 如果满足的话 都移动然后$ans++$，不满足的话，右指针左移值减小，然后右边的单独放一个。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="comment">//#define endl '\n'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> w, n;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">   &#125;</span><br><span class="line">   sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">   <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">   <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">       <span class="keyword">if</span>(a[l] + a[r] &lt;= w) &#123;</span><br><span class="line">           ans++, l++,r--;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ans++;</span><br><span class="line">           r--;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NC16783-拼数"><a href="#NC16783-拼数" class="headerlink" title="NC16783:拼数"></a>NC16783:拼数</h3><p>思路:</p>
<p>因为是拼接操作，我们可以把数字当成字符串来处理，考虑拼接我们可以将每一个字符串排序，按照拼接后的顺序写$cmp$函数</p>
<p>这一步非常巧妙，假设$a=321，b=32$,$a+b=32132，b+a=32321$这样下面sort排下来就是32&gt;321避免出现32132&gt;32321的情况  ,因此我们采用拼接再排序。</p>
<p>然后按照升序排列后从后往前输出即可。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">   &#125;</span><br><span class="line">   sort(s + <span class="number">1</span>, s + <span class="number">1</span> + n, cmp);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NC15553-数学考试"><a href="#NC15553-数学考试" class="headerlink" title="NC15553:数学考试"></a>NC15553:数学考试</h3><p><strong>思路1:</strong></p>
<p>求两段连续不相交的子区间使和最大。</p>
<p>考虑先用前缀和维护出某一段的区间和。</p>
<p>然后我们要求<strong>某个位置之前和之后的和最大</strong>的区间。</p>
<p>线性DP求一下 设$l_i$表示位置$i$之前的最大区间和，$r_i$表示位置$i$之后的最大区间和。</p>
<p>因此有：</p>
<script type="math/tex; mode=display">
l_i = max(l_{i - 1}, sum_i - sum_{i - k})\\
r_i = max(r_{i + 1},sum_{i + k - 1} - sum_{i - 1})</script><p>注意数据范围还有遍历范围 详见代码……</p>
<p><strong>注意点：</strong></p>
<ul>
<li>$ans$的取值要取尽可能小…不然只过83.3%的数据范围…【其实我也不知道开多大qwq】</li>
<li>这题玄学…memset能过 遍历赋值过不了qwq</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, k;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">ll sum[maxn];</span><br><span class="line">ll l[maxn], r[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">   <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">       ans = <span class="number">-1e18</span>;</span><br><span class="line">       <span class="comment">//要开1e18 不然83%样例 不能-INF</span></span><br><span class="line">       <span class="comment">//memset(a, 0, sizeof(a));</span></span><br><span class="line">       <span class="comment">//memset(sum, 0, sizeof(sum));</span></span><br><span class="line">       <span class="built_in">memset</span>(l, -INF, <span class="keyword">sizeof</span>(l));</span><br><span class="line">       <span class="built_in">memset</span>(r, -INF, <span class="keyword">sizeof</span>(r));</span><br><span class="line">       <span class="comment">/* for(int i = 1; i &lt;= maxn; i++) &#123;</span></span><br><span class="line"><span class="comment">           l[i] = r[i] = -INF;//玄学问题</span></span><br><span class="line"><span class="comment">       &#125;  */</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">           sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n - k; i++) &#123;</span><br><span class="line">           l[i] = <span class="built_in">max</span>(l[i - <span class="number">1</span>], sum[i] - sum[i - k]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &gt;= k + <span class="number">1</span>; i--) &#123;</span><br><span class="line">           r[i] = <span class="built_in">max</span>(r[i + <span class="number">1</span>], sum[i + k - <span class="number">1</span>] - sum[i - <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n - k; i++) &#123;</span><br><span class="line">           ans = <span class="built_in">max</span>(ans, l[i] + r[i + <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong></p>
<p>前缀和处理之后，维护前缀和中长度为k的最大值m1，枚举第二个长度为k的起点，答案就是max(m1 + 当前长度为k的序列和).</p>
<p>时间复杂度：$O(n)$</p>
<p>注意枚举的范围 $i + k &lt;= n$，要留出第二个的范围。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, k;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">ll sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">   <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++) &#123;</span><br><span class="line">           a[i] = sum[i] = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">           sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">       &#125;</span><br><span class="line">       ll m1 = <span class="number">-1e18</span>, ans = <span class="number">-1e18</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i + k &lt;= n; i++) &#123;</span><br><span class="line">           m1 = <span class="built_in">max</span>(m1, sum[i] - sum[i - k]);</span><br><span class="line">           ans = <span class="built_in">max</span>(ans, m1 + sum[i + k] - sum[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NC16561-国王的游戏"><a href="#NC16561-国王的游戏" class="headerlink" title="NC16561:国王的游戏"></a>NC16561:国王的游戏</h3><p>思路:</p>
<p>贪心思路+高精度【涉及大数乘除运算】…</p>
<p>贪心证明见PPT， 高精度还是用$Python$写舒服啊[滑稽~]</p>
<p>贪心数学证明可见：<a href="https://www.luogu.com.cn/problem/solution/P1080" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/solution/P1080</a></p>
<p>pthyon写法详见：<a href="https://www.cnblogs.com/coderzjz/p/12745550.html" target="_blank" rel="noopener">https://www.cnblogs.com/coderzjz/p/12745550.html</a></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">s = input().split()</span><br><span class="line">S = int(s[<span class="number">0</span>])</span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    k = input().split()</span><br><span class="line">    a.append((int(k[<span class="number">0</span>]), int(k[<span class="number">1</span>])))</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>] * x[<span class="number">1</span>])<span class="comment">#按照乘积升序排列</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">    <span class="keyword">if</span>(S // (a[i])[<span class="number">1</span>] &gt; ans):<span class="comment">#整除 按照题意找最大</span></span><br><span class="line">        ans = S // (a[i])[<span class="number">1</span>]<span class="comment">##替换最大ans</span></span><br><span class="line">    S *= (a[i])[<span class="number">0</span>]<span class="comment">#前方所有左手的乘积</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>
<h3 id="NC24636-值周"><a href="#NC24636-值周" class="headerlink" title="NC24636:值周"></a>NC24636:值周</h3><p>思路:</p>
<p>类似题目NC16649:校门外的树</p>
<p>题目范围$L$和$M$过大，如果嵌套的话，必定超时 我们考虑每次操作修改的实际是大区间中的小区间值，于是我们可以考虑<strong>离散化</strong>处理。</p>
<p>我们按照区间的左端点进行升序排序，然后处理。</p>
<p>画个图可以理解一下区间的覆盖</p>
<ul>
<li>第一个区间被移走的人数是$r-l+1$,标记当前$end=r$。</li>
<li>如果下一个区间的$l$比$end$大，移走的人数是$r-l+1$,更新$end$。</li>
<li>如果下一个区间的$r$不小于$end$，移走的人数是$r-end$,更新$end$。</li>
<li>最后剩余的是$L - sum + 1$。输出的时候，注意位置 0 也有一棵树，所以总数量要加 1 。</li>
</ul>
<p><img src="/2020/05/20/nowcoder-%E5%85%A5%E9%97%A8%E8%AF%BE1/NC24636.png" alt></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">ll L, M;</span><br><span class="line">ll l, r;</span><br><span class="line">pair&lt;ll, ll&gt;pr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; M;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">      pr[i] = make_pair(l, r);</span><br><span class="line">   &#125;</span><br><span class="line">   sort(pr + <span class="number">1</span>, pr + <span class="number">1</span> + M);</span><br><span class="line">   ll sum = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pr[i].first &gt;= <span class="built_in">end</span>) &#123; <span class="comment">//interval_range</span></span><br><span class="line">         sum += pr[i].second - pr[i].first + <span class="number">1</span>;</span><br><span class="line">         <span class="built_in">end</span> = pr[i].second;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pr[i].second &gt;= <span class="built_in">end</span>) &#123;</span><br><span class="line">         sum += pr[i].second - <span class="built_in">end</span>;</span><br><span class="line">         <span class="built_in">end</span> = pr[i].second;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; L - sum + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种是差分思路。可以尝试理解一下，记录区间端点的变化，而不关心区间内部的细节。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e8</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> L, M;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; M;</span><br><span class="line">   a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">   		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">   		a[l] += <span class="number">1</span>;</span><br><span class="line">   		a[r + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ll sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; i++) &#123;</span><br><span class="line">   		sum += a[i];</span><br><span class="line">   		<span class="keyword">if</span>(sum == <span class="number">1</span>) &#123;</span><br><span class="line">   				ans++;</span><br><span class="line">		   &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NC14709-奇♂妙拆分"><a href="#NC14709-奇♂妙拆分" class="headerlink" title="NC14709:奇♂妙拆分"></a>NC14709:奇♂妙拆分</h3><p>思路:</p>
<p><strong>枚举思路</strong></p>
<p>考虑类似质因数分解，但要求分解的不可以有重复的，例如分解$7$,可以分解成$1$和$7$的组合。其中一部分肯定大于$sqrt(n)$。所以我们可以设置$ans$的初始值为$1$，表示总有一个数字大于$sqrt(n)$的因子。</p>
<p>这样我们下边就可以模仿分解质因数的方式，满足不重复即可，把$while$条件改成$if$,如果满足就分解出该因子即可，按照从小到大的顺序。</p>
<p>可能在一遍循环之后，n并没有如愿的变成1（有些情况下因数大于$sqrt(n)$，有些情况下i大于当前的n且n没能变为1），所以我们要分别考虑这两种情况，对第一种情况，这种因数只会出现一次，所以在循环结束后将$res + 1$即可，对于第二种情况，这个n一定不能作为新的质因数产生了，因为如果它是一个新的质因数，那么i在循环到该值时会产生对应的质因数，所以它只能与其他数一起产生一个合数。</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">   <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">       solve();</span><br><span class="line">   &#125;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="NC14583-糖糖别胡说，我真的不是签到题目"><a href="#NC14583-糖糖别胡说，我真的不是签到题目" class="headerlink" title="NC14583:糖糖别胡说，我真的不是签到题目"></a>NC14583:糖糖别胡说，我真的不是签到题目</h3><p>思路:</p>
<p>考虑糖糖消失有条件:</p>
<ul>
<li>糖糖比前边那个能力值大且不属于同一组。</li>
</ul>
<p>实际上，糖糖的消失并没有直接的关系，发功影响的是整个区间的值都$+1$。</p>
<p>区间都增加/减少问题我们可以考虑差分数组来维护再求前缀和来降低复杂度。就是每次记录区间的更改，然后再更新整个区间emm</p>
<p>注意每次干掉都是干掉之前的小的,如果从前往后判断，每次都要找比当前小的值，因此，我们题意可以维护最大值,从后向前维护两组的各自最大值,并保留.</p>
<p>emm…看代码就可以辣~</p>
<p>注意可以用结构体来存,空间开大点…<br>数据范围大概要开到$5e6 +5$，不然会段错误qwq~</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">int</span> value;</span><br><span class="line">&#125;sweet[maxn];</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> c[maxn], d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">   <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">         <span class="built_in">cin</span> &gt;&gt; sweet[i].id &gt;&gt; sweet[i].value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">         <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">         d[<span class="number">1</span>]++;</span><br><span class="line">         d[c[i] + <span class="number">1</span>]--;</span><br><span class="line">      &#125;</span><br><span class="line">      ll sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">         sum += d[i];</span><br><span class="line">         sweet[i].value += sum;</span><br><span class="line">         <span class="comment">/* d[i] = d[i - 1] + d[i];</span></span><br><span class="line"><span class="comment">         sweet[i].value += d[i]; */</span></span><br><span class="line">      &#125;</span><br><span class="line">      ll max1 = -INF, max2 = -INF;<span class="comment">//强制类型转换</span></span><br><span class="line">      ll ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">         <span class="keyword">if</span>(sweet[i].id) &#123;</span><br><span class="line">            max1 = <span class="built_in">max</span>(max1, (ll)sweet[i].value);</span><br><span class="line">            <span class="keyword">if</span>(sweet[i].value &gt;= max2) &#123;</span><br><span class="line">               ans++;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max2 = <span class="built_in">max</span>(max2, (ll)sweet[i].value);</span><br><span class="line">            <span class="keyword">if</span>(sweet[i].value &gt;= max1) &#123;</span><br><span class="line">               ans++;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>模拟</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces-Round-640-Div-4</title>
    <url>/2020/05/10/Codeforces-Round-640-Div-4/</url>
    <content><![CDATA[<p>菜鸡的$div4$补题现场……</p>
<p>(真就尼玛见证历史)……</p>
<a id="more"></a>
<h3 id="A-Sum-of-Round-Numbers"><a href="#A-Sum-of-Round-Numbers" class="headerlink" title="A:Sum of Round Numbers"></a>A:Sum of Round Numbers</h3><p>1.题目描述：</p>
<p>给你一个$n$，拆成$round$数。</p>
<p>$round$数：除最高位以外的其他位所有数字都是0，则成为$round$数。</p>
<p>$1$~$9$所有的数字都是$round$。</p>
<p><em>input:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5009</span><br><span class="line">7</span><br><span class="line">9876</span><br><span class="line">10000</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5000 9</span><br><span class="line">1</span><br><span class="line">7 </span><br><span class="line">4</span><br><span class="line">800 70 6 9000 </span><br><span class="line">1</span><br><span class="line">10000 </span><br><span class="line">1</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>2.思路</p>
<p>类似于拆分一个整数$n$， 我们对其每一位判断然后乘上该位置的对应的$10$的倍数即可。</p>
<p>[比赛中 没有看到这一句话]……</p>
<p>$The \ terms\ can\ be \ printed \ in \ any \ order.$</p>
<p>补题的时候我尼玛人都傻了  可以以任何顺序输出…..fuck</p>
<p>我们就可以随便搞了 用一个$a$数组来记录$answer$，然后做整数的取位处理即可。</p>
<p><strong>技巧</strong>：</p>
<p>对于$\%$运算，取最后一位</p>
<p>对于$/$运算，取除当前位的其他所有位…..</p>
<p>（小声：这TM不就是常识…做题太少……）</p>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(X) (int)X.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, cnt;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>];<span class="comment">//保存答案</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">   <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">      cnt = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">      <span class="keyword">while</span>(n) &#123;</span><br><span class="line">         <span class="keyword">if</span>(n % <span class="number">10</span>) &#123;</span><br><span class="line">            a[cnt++] = n % <span class="number">10</span> * d;</span><br><span class="line">         &#125;</span><br><span class="line">         d *= <span class="number">10</span>;</span><br><span class="line">         n /= <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="comment">/* while(n) &#123;</span></span><br><span class="line"><span class="comment">         cout &lt;&lt; "###" &lt;&lt; n % 10 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">         cout &lt;&lt; "$$$" &lt;&lt; n / 10 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">         n /= 10;</span></span><br><span class="line"><span class="comment">         cout &lt;&lt; "The answer about n:" &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">      &#125; */</span> </span><br><span class="line">   &#125;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-Same-Parity-Summands"><a href="#B-Same-Parity-Summands" class="headerlink" title="B:Same Parity Summands"></a>B:Same Parity Summands</h3><p>1.题目描述</p>
<p><em>input:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.思路：</p>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="C"><a href="#C" class="headerlink" title="C:"></a>C:</h3><p>1.题目描述</p>
<p><em>input：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>output：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.思路：</p>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="D"><a href="#D" class="headerlink" title="D:"></a>D:</h3><p>1.题目描述：</p>
<p><em>input:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.思路</p>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces-Round-636-Div-3</title>
    <url>/2020/04/26/Codeforces-Round-636-Div-3/</url>
    <content><![CDATA[<p>菜鸡的$div3$补题现场……</p>
<a id="more"></a>
<h3 id="A-Candies"><a href="#A-Candies" class="headerlink" title="A:Candies"></a>A:Candies</h3><p>1.题目描述：</p>
<p>给你一个n, 让你找到满足$x + 2x + 4x + \dots + 2^{k-1} x = n $ 的$x$整数值。其中 $k &gt; 1$</p>
<p><em>input:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">21</span><br><span class="line">28</span><br><span class="line">999999999</span><br><span class="line">999999984</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">333333333</span><br><span class="line">333333328</span><br></pre></td></tr></table></figure>
<p>2.思路</p>
<p>考虑：</p>
<script type="math/tex; mode=display">
(1+ 2 + 4 + 2^{k-1})x = n;\\
x = \frac{n}{(1 + 2 + 4 + 2^{k - 1})};\\
notice:\\
(1+2+4+2^{k-1}) \\
= \begin{equation*}
\sum_{i=0}^{k-1}2^i
\end{equation*}\\
= 2^k - 1;\\
then:\\
x = \frac{n}{2^k - 1};\\</script><p>我们令$k  = 2$ 开始遍历$k$即可，整除时输出$x$然后$break$。</p>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">   <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; ; k++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(n % ((<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt; n / ((<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-Balanced-Array"><a href="#B-Balanced-Array" class="headerlink" title="B:Balanced Array"></a>B:Balanced Array</h3><p>1.题目描述</p>
<p>给$n$（保证n是偶数）,然后找一个序列长度是$n$</p>
<ul>
<li>前$\frac{n}{2}$个序列元素是偶数</li>
<li>后$\frac{n}{2}$个序列元素是奇数</li>
<li>所有元素都是正整数</li>
<li>前$\frac{n}{2}$和后$\frac{n}{2}$的和相等 即：<script type="math/tex">\sum\limits_{i = 1}^{\frac{n}{2}} a_i = \sum\limits_{i=\frac{n}{2} + 1}^{n} a_i</script></li>
</ul>
<p><em>input:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">2 4 1 5</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">2 4 6 8 1 3 5 11</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<p>2.思路：</p>
<p>构造题</p>
<p>我们首先判断 对于给定的$n$,是否存在满足题目要求的序列。</p>
<p>如果$n / 2 % 2 ==1$证明无解 输出$”NO”$。举例证明即可：</p>
<p>当$n = 6$时，前半部分长度和后半部分长度均为$3$，则其和不可能相等。</p>
<p>判断一下$n / 2$之后即可【注意此处的写法 开采用$continue$来继续处理】……</p>
<p>接下来我们就可以去构造两个长度为$\frac{n}{2}$的序列。</p>
<p>令 $cnt = \frac{n}{2}$</p>
<p>通过$for$循环输出每次的$i$我们可以把前$cnt$次的偶数序列构造完毕。</p>
<p>通过$for$循环输出每次的$i$我们可以把前$cnt- 1$次的技术序列构造完毕 但前$cnt$项与上边每一项相比 少了$1$ 于是我们后边对于第$cnt$项输出$2 * cnt - 1 + cnt$.[上边偶数项对应$-1 + $前边缺少的每一项累加起来的和]</p>
<p>我才用的是另一种方法：设置两个标记计算两个$sum$ 然后判断一下$sum$之间的大小 然后输出差即可。</p>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">   <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">       <span class="keyword">int</span> ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">       n /= <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> * i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">           ans1 += i * <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> * i - <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">           ans2 += <span class="number">2</span> * i - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//cout &lt;&lt; 2 * n - 1 + n &lt;&lt;endl;[第一种解法]</span></span><br><span class="line">       <span class="keyword">if</span>(ans1 &gt; ans2) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; ans1 - ans2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; ans2 - ans1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; "###1:" &lt;&lt; ans1  &lt;&lt; " " &lt;&lt; "###2:" &lt;&lt; ans2 &lt;&lt; endl;</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//    system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-Alternating-Subsequence"><a href="#C-Alternating-Subsequence" class="headerlink" title="C:Alternating Subsequence"></a>C:Alternating Subsequence</h3><p>1.题目描述</p>
<p>交错子序列问题</p>
<p>定义：如果一个序列$a$可以通过删除$0$个或多个元素而不改变其余元素的顺序而得到$b$，那么称：$b$是$a$的子序列。</p>
<p>给你一个不包含$0$的长度为$n$的正负元素序列。</p>
<p>你的任务是找到一个具有最<strong>大</strong>元素总数的交错子序列. 交错序列就是下一个元素的符号与当前元素的服好相反.[类似 $+-+$/$-+-$]</p>
<p>$n$的范围：$1 \le n \le 2 \cdot 10^5$</p>
<p><em>input：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">1 2 3 -1 -2</span><br><span class="line">4</span><br><span class="line">-1 -2 -1 -3</span><br><span class="line">10</span><br><span class="line">-2 8 3 8 -4 -15 5 -2 -3 1</span><br><span class="line">6</span><br><span class="line">1 -1000000000 1 -1000000000 1 -1000000000</span><br></pre></td></tr></table></figure>
<p><em>output：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">-1</span><br><span class="line">6</span><br><span class="line">-2999999997</span><br></pre></td></tr></table></figure>
<p>2.思路：</p>
<ol>
<li><p>采用双指针$i$和$j$来用<strong>贪心</strong>求解。</p>
<p>从序列开头 往后双指针 $i,j$计算，分别表示当前和下一个的下标。</p>
<p>然后我们$while$一下，判断条件就是当$j + 1&lt;= n$时，并且前后元素是异号的时候, $ans$加上该同号区间的最大值。然后将$j$的值赋给$i$，继续处理下一个区间。</p>
</li>
<li><p>codeforces上给了一个更为清晰的写法 但大致原理是相同的：</p>
<p>就是寻找当前同号区间中的最大值，然后和下一个区间（与上一个区间异号）的最大值相加就是$ans$。注意更新$i j $的区间值。</p>
</li>
<li><p>采用$dp$.</p>
<p>详见代码注释</p>
</li>
</ol>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法1 or 2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">   <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">       <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">       ll ans = <span class="number">0</span>;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> j = i;</span><br><span class="line">           ll now = a[i];</span><br><span class="line">           <span class="keyword">while</span>(j + <span class="number">1</span> &lt;= n &amp;&amp; ((a[i] &gt; <span class="number">0</span> &amp;&amp; a[j + <span class="number">1</span>] &gt; <span class="number">0</span>) || (a[i] &lt; <span class="number">0</span> &amp;&amp; a[j + <span class="number">1</span>] &lt; <span class="number">0</span>))) &#123;</span><br><span class="line">               j++;</span><br><span class="line">               now = <span class="built_in">max</span>(now, a[j]);</span><br><span class="line">           &#125;</span><br><span class="line">           i = j;</span><br><span class="line">           ans += now;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//    system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法3</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, ll&gt;dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[i][0].first表示前i项交错子序列以正数结尾的最长长度</span></span><br><span class="line"><span class="comment">//dp[i][0].second表示前i项交错子序列以正数结尾的最长长度的最大和</span></span><br><span class="line"><span class="comment">//dp[i][1].first表示前i项交错子序列以负数结尾的最长长度</span></span><br><span class="line"><span class="comment">//dp[i][1].second表示前i项交错子序列以负数结尾的最长长度的最大和</span></span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">   <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">           dp[i][<span class="number">0</span>] = make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">           dp[i][<span class="number">1</span>] = make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i][<span class="number">0</span>]);</span><br><span class="line">           dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i][<span class="number">1</span>]);</span><br><span class="line">           <span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], make_pair(dp[i - <span class="number">1</span>][<span class="number">1</span>].first + <span class="number">1</span>, dp[i - <span class="number">1</span>][<span class="number">1</span>].second + a[i]));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], make_pair(dp[i - <span class="number">1</span>][<span class="number">0</span>].first + <span class="number">1</span>, dp[i - <span class="number">1</span>][<span class="number">0</span>].second + a[i]));</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//    cout &lt;&lt; "###1:" &lt;&lt; dp[i][0].first &lt;&lt; " " &lt;&lt; "###2:" &lt;&lt; dp[i][0].second &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//    cout &lt;&lt; "$$$1:" &lt;&lt; dp[i][1].first &lt;&lt; " " &lt;&lt; "$$$2:" &lt;&lt; dp[i][1].second &lt;&lt; endl;</span></span><br><span class="line">       &#125;</span><br><span class="line">       pair&lt;<span class="keyword">int</span>, ll&gt;ans;</span><br><span class="line">       ans = <span class="built_in">max</span>(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]);</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; ans.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces-Round-632-Div-2</title>
    <url>/2020/04/11/Codeforces-Round-632-Div-2/</url>
    <content><![CDATA[<p>菜鸡的$div2$补题现场……</p>
<a id="more"></a>
<h3 id="A-Little-Artem"><a href="#A-Little-Artem" class="headerlink" title="A:Little Artem"></a>A:Little Artem</h3><p>1.题目描述：</p>
<p>给你一个$n * m$的矩形，现在让你涂色。$’B’$表示黑色，$’W’$表示白色。</p>
<p>Lets $B$ be the number of black cells that have at least one white neighbor adjacent by the side. Let $W$ be the number of white cells that have at least one black neighbor adjacent by the side. </p>
<p>先（重新）定义：</p>
<ul>
<li>$’B’$表示具有至少一个相邻的白色邻居的单元格数量。</li>
<li>$‘W’$表示具有至少一个相邻的黑色邻居的单元格数量。</li>
</ul>
<p>当$B = W + 1$时，我们称该矩形是好的。</p>
<p>让你输出任何一个好的矩形。</p>
<p><em>input:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BW</span><br><span class="line">WB</span><br><span class="line">BB</span><br><span class="line">BWB</span><br><span class="line">BWW</span><br><span class="line">BWB</span><br></pre></td></tr></table></figure>
<p>2.思路</p>
<p>【！！！读题仔细！！！】</p>
<p>所以我们可以构造出一个样例，即构造出$2 (B)= 1(W) + 1$这种，就满足题目要求。</p>
<p>我们就可以让随便一个位置为$W$,然后构造两个$B$围着即可。</p>
<p>即矩形四个角的位置设置为$W$,其他均为$B$即可。</p>
<p><strong>【qwq 我没有想到www~】</strong></p>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">   <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == m) &#123;<span class="comment">//判断条件随便写 构造即可</span></span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt;<span class="string">'W'</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt;<span class="string">'B'</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-Kind-Anton"><a href="#B-Kind-Anton" class="headerlink" title="B:Kind Anton"></a>B:Kind Anton</h3><p>1.题目描述</p>
<p>一个$a$数组，里边的元素只有${-1, 0, 1}$，你可以执行操作：</p>
<ul>
<li>选择一对$(i, j)$满足$1 \le i &lt; j \le n$,可以多次选择同一对。</li>
<li>将$a_i$ 加到$a_j$上， 即:$a_j = a_i + a_j$</li>
</ul>
<p>问：给你一个$a$, $b$，能否对$a$进行上述操作，使得成为$b$数组？输出”YES/NO”</p>
<p>数据量：</p>
<ul>
<li>T组数据：$1\le t \le 10000$</li>
<li>N—数组长度：$1\le n \le 10^5$</li>
</ul>
<p><em>input:</em>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br><span class="line">1 -1 0</span><br><span class="line">1 1 -2</span><br><span class="line">3</span><br><span class="line">0 1 1</span><br><span class="line">0 2 2</span><br><span class="line">2</span><br><span class="line">1 0</span><br><span class="line">1 41</span><br><span class="line">2</span><br><span class="line">-1 0</span><br><span class="line">-1 -41</span><br><span class="line">5</span><br><span class="line">0 1 -1 1 -1</span><br><span class="line">1 1 -1 1 -1</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<p>2.思路：</p>
<p>思维题</p>
<p>我们考虑，既然$i &lt; j$恒成立，则：当$a_j &lt;= a_j$时，我们就可以通过无限次累加$1$使得成立。</p>
<p>即：当$a_j &gt;= a_j$时，我们也可以通过无限次累加$-1$使得成立。</p>
<p>所以我们要做的判断就是当$a_j &lt;= b_j$时，是否存在$1$使得可以成立。 $&gt;=$情况同理。</p>
<p>具体细节见代码。</p>
<p>逻辑判断条件要搞清….不然会很乱….</p>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, x;</span><br><span class="line"><span class="comment">//vector&lt;int&gt;a,b;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>, x1 = <span class="literal">false</span>, x2 = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i] &amp;&amp; !x1) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; b[i] &amp;&amp; !x2) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            x1 = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">            x2 = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">   <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">       <span class="comment">//int x;</span></span><br><span class="line">       <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">       <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">          <span class="comment">/*  cin &gt;&gt; x;</span></span><br><span class="line"><span class="comment">           a.push_back(x); */</span></span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; a[i]; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">          <span class="comment">/*  cin &gt;&gt; x;</span></span><br><span class="line"><span class="comment">           b.push_back(x); */</span></span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; b[i]; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* for(int x : a) &#123;</span></span><br><span class="line"><span class="comment">           cout &lt;&lt; x &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">       for(int x : b) &#123;</span></span><br><span class="line"><span class="comment">           cout &lt;&lt; x &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">       &#125; */</span></span><br><span class="line">       <span class="keyword">if</span>(solve()) &#123;</span><br><span class="line">           <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-Eugene-and-an-array"><a href="#C-Eugene-and-an-array" class="headerlink" title="C:Eugene and an array"></a>C:Eugene and an array</h3><p>1.题目描述</p>
<p>给你一个序列$a$，让你找出$a$的所有$sum != 0$的子序列个数。</p>
<p><em>input：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first:</span><br><span class="line">3</span><br><span class="line">1 2 -3</span><br><span class="line">second:</span><br><span class="line">3</span><br><span class="line">41 -41 41</span><br></pre></td></tr></table></figure>
<p><em>output：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first:</span><br><span class="line">5</span><br><span class="line">second:</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>2.思路：</p>
<p>子序列$sum$问题考虑前缀和。</p>
<p>题目中说明：一个序列的子序列如果$sum == 0$那么也不是一个$good$序列。于是我们可以用一个$map$来维护当前的前缀和，即：维护$sum$和对应的下标$i$。</p>
<p>！！！注意！！求前缀和的时候，原来的每一项数据范围是$int$，可能会爆$int$,所以我们采用$long long map$来维护。</p>
<p>【就是$map$保存前缀和嘛~出现前缀和相同，就是证明里边有$sum == 0$的子串，我们就去找最大左端点，然后用当前减去即可。】</p>
<p>思路就是 :</p>
<ul>
<li>我们首先对每一个i 找包含$a[i]$的子串的个数 </li>
<li>显然为$n$个，证明：对于第$i$个，左边有$i - 1$个，右边有$n - i$个，包含自身，即：$i - 1 + 1 + n - i$ 为$n$</li>
<li>我们可以枚举每一个$a[i]$，求出其往左延伸有多少符合的子串，然后我们在加一下即可。</li>
<li>对每一个$a[i]$，我们最后$ans += i - (max_l + 1)$[注意要+1，$max_l$ 表示前缀和相等的下标，实际区间要多减去1]</li>
</ul>
<p><img src="/2020/04/11/Codeforces-Round-632-Div-2/picture2.png" alt></p>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">"\n"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt;mp;<span class="comment">//每一个前缀和出现的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">   &#125;</span><br><span class="line">   ll sum = <span class="number">0</span>;</span><br><span class="line">   mp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   ll temp = <span class="number">-1</span>;<span class="comment">//当前位置 区间 注意初始化</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">       sum += a[i];</span><br><span class="line">       <span class="keyword">if</span>(mp.count(sum)) &#123;</span><br><span class="line">           temp = <span class="built_in">max</span>(temp, mp[sum]);</span><br><span class="line">       &#125;</span><br><span class="line">       mp[sum] = i;<span class="comment">//更新</span></span><br><span class="line">       ans += i - (temp + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-1031-查验身份证</title>
    <url>/2020/04/10/PTA-1031-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><blockquote>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805290334011392" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805260223102976/problems/994805290334011392</a></p>
</blockquote>
<p><strong>数据范围</strong>:</p>
<p>N &lt;= 100</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first:</span><br><span class="line">4</span><br><span class="line">320124198808240056</span><br><span class="line">12010X198901011234</span><br><span class="line">110108196711301866</span><br><span class="line">37070419881216001X</span><br><span class="line">second:</span><br><span class="line">2</span><br><span class="line">320124198808240056</span><br><span class="line">110108196711301862</span><br></pre></td></tr></table></figure>
<p><em>Output</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first:</span><br><span class="line">12010X198901011234</span><br><span class="line">110108196711301866</span><br><span class="line">37070419881216001X</span><br><span class="line">second:</span><br><span class="line">All passed</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><p>题意清楚 我们只需要计算一下前$17$位的$sum$，并在计算过程中，判断一下是否有$s[i]$不属于数字即可。然后在算权值的过程中，最好建一个对应的数组，便于相乘。</p>
<p>注意对$X$的处理，全是数字，我们尽可能的转换成同类型$int$来操作。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">17</span>] = &#123;<span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">11</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt;<span class="string">'0'</span> || s[i] &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (s[i] - <span class="string">'0'</span>) * a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = (s[<span class="number">17</span>] == <span class="string">'X'</span>) ? <span class="number">10</span> : (s[<span class="number">17</span>] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> temp == ans[sum % <span class="number">11</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">   flag = <span class="literal">false</span>;<span class="comment">//所有的都要去满足 定义在while内部可能出现第一个满足，结果后边的不满足情况</span></span><br><span class="line">   <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">       <span class="keyword">if</span>(!solve()) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">           flag = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"All passed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><p>坑点：</p>
<p>注意$flag$的定义赋值范围，要在所有的$test$之外，要求的是，对于所有的样例都满足的时候，才可以输出$All passed$</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>无（占坑）</p>
</blockquote>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #631(Div. 2)</title>
    <url>/2020/04/08/Codeforces-Round-631-Div-2/</url>
    <content><![CDATA[<p>菜鸡的$div2$补题现场……</p>
<a id="more"></a>
<h3 id="A-Dreamoon-and-Ranking-Collection"><a href="#A-Dreamoon-and-Ranking-Collection" class="headerlink" title="A:Dreamoon and Ranking Collection"></a>A:Dreamoon and Ranking Collection</h3><p>1.题目描述：</p>
<p>给你一个$n$和$x$,然后有$n$个数据,这个人从$1$开始比赛，$n$组数据包含着这个人进行的比赛，未进行的比赛可以用$x$补全，但$x$也要相应$-1$</p>
<p>问：他能够到达的最大比赛次数是多少？</p>
<p><em>input:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">6 2</span><br><span class="line">3 1 1 5 7 10</span><br><span class="line">1 100</span><br><span class="line">100</span><br><span class="line">11 1</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">1 1</span><br><span class="line">1</span><br><span class="line">4 57</span><br><span class="line">80 60 40 20</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">101</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">60</span><br></pre></td></tr></table></figure>
<p>2.思路</p>
<p>我们可以从$1$开始往后扫一边，对应的$ans += 1$,如果这个地方是空，我们给他填上，并且$x$相应$-1$，直到$x == 0$，看此时的$ans$就是我们可以得到的最大的比赛值。</p>
<p>这里存储的是每一场比赛对应的值，我们可以用一个$map$来存储。</p>
<p>注意：</p>
<ul>
<li>变量全局定义，记得初始化。</li>
<li>$for$循环的判断条件</li>
<li>$map$的清空[不然多组样例会wa掉]</li>
</ul>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, x, temp,cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">   <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">       n = x = temp = cnt = <span class="number">0</span>;</span><br><span class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;mp;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">           mp[temp] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* for(int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">           cout &lt;&lt; mp[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">       &#125; */</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; ; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(x == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(mp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//cout &lt;&lt; "#1:" &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">               x -= <span class="number">1</span>;</span><br><span class="line">               mp[i] = <span class="number">1</span>;</span><br><span class="line">               <span class="comment">//cout &lt;&lt; "#2:" &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* for(int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">           cout &lt;&lt; mp[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">       &#125; */</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; mp[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">           <span class="comment">//cout &lt;&lt; mp[i] &lt;&lt; endl;</span></span><br><span class="line">           cnt++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-Dreamoon-Likes-Permutations"><a href="#B-Dreamoon-Likes-Permutations" class="headerlink" title="B:Dreamoon Likes Permutations"></a>B:Dreamoon Likes Permutations</h3><p>1.题目描述</p>
<p>定义一个$permutation$,如果对于一个序列，包含了从$1$到$n$的每一项，则该序列称为$permutation$.</p>
<p>有两个符合$permutation$的序列$p1, p2$, 长度分别为$l1, l2$。现在连接成为一个长度为$l1 + l2$的序列$a$，第一个$l1$元素是$p1$， 下一个$l2$元素是$p2$.</p>
<p>现在给你一个序列$a$，让你找两个符合$permutation$的序列$p1， p2$，找到还原它们的所有方法。 </p>
<p>输出存在的方法并输出$p1$ 和 $p2$的长度.</p>
<p><em>input:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5</span><br><span class="line">1 4 3 2 1</span><br><span class="line">6</span><br><span class="line">2 4 1 3 2 1</span><br><span class="line">4</span><br><span class="line">2 1 1 3</span><br><span class="line">4</span><br><span class="line">1 3 3 1</span><br><span class="line">12</span><br><span class="line">2 1 3 4 5 6 7 8 9 1 10 2</span><br><span class="line">3</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 4</span><br><span class="line">4 1</span><br><span class="line">1</span><br><span class="line">4 2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2 10</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>2.思路：</p>
<p>u1s1，一开始看到题意有点懵，读了两遍题，才大致了解了一下。</p>
<p>我们可以想一下，对于一个序列，如果它是符合$permutation$这个条件的，则其最大值我们设定是$ma$，如果$a$序列可以分割，则其最大值为$max(len1, len2)$</p>
<p>所以会有两种解决方案：</p>
<ul>
<li>$len1 = ma, len2 = n - ma$</li>
<li>$len1 = n - ma, len2 = ma$</li>
</ul>
<p>我们只需要检查这两种分割方式是否符合$permutation$即可。</p>
<p>我们可以用一个标记数组$vis$来判断该序列从$1$到$len1$是否全部出现即可。</p>
<p><strong>注意</strong> ：序列两部分的断点  ，不要去考虑原数组，只需要考虑$vis$是否符合$permutation$即可。</p>
<p>提供一组样例：【需要特判！！！】</p>
<p><em>input:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 3 2 1</span><br></pre></td></tr></table></figure>
<p><em>output:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p>3.代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="keyword">int</span> a[maxn], vis[maxn], ans[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l1; i++) &#123;</span><br><span class="line">        vis[a[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l1; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l1 + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        vis[a[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l2; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">   <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">       <span class="keyword">int</span> ma = <span class="number">-1</span>;</span><br><span class="line">       <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">       <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">       <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">           ma = <span class="built_in">max</span>(ma, a[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(check(ma, n - ma)) &#123;</span><br><span class="line">           cnt++;</span><br><span class="line">           ans[cnt][<span class="number">0</span>] = ma;</span><br><span class="line">           ans[cnt][<span class="number">1</span>] = n - ma;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(ma * <span class="number">2</span> != n &amp;&amp; check(n - ma, ma)) &#123; <span class="comment">//判重复方案</span></span><br><span class="line">           cnt++;</span><br><span class="line">           ans[cnt][<span class="number">0</span>] = n - ma;</span><br><span class="line">           ans[cnt][<span class="number">1</span>] = ma;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; ans[i][<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[i][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-Dreamoon-Likes-Coloring"><a href="#C-Dreamoon-Likes-Coloring" class="headerlink" title="C. Dreamoon Likes Coloring"></a>C. Dreamoon Likes Coloring</h3><p>1.题目描述</p>
<p>给你一个长度为$n$的长条单元格让你涂色，可以进行$m$次涂色操作，分别给定$l_1, l_2, \ldots, l_m$。</p>
<p>对第$i$次操作，你可以选择一个$p_i$在$[1, n - l_i + 1]$ 范围内，并对$p_i$到$p_i + l_i -1$所有的单元格进行涂色。后来涂色的单元格颜色可以覆盖之前进行的涂色。</p>
<p>你的任务：在$m$次操作后：</p>
<ul>
<li>所有的颜色出现一次</li>
<li>并所有单元格都有颜色。[即有m种颜色…..]</li>
</ul>
<p><em>input：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first:</span><br><span class="line">5 3</span><br><span class="line">3 2 2</span><br><span class="line">second:</span><br><span class="line">10 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><em>output：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first:</span><br><span class="line">2 4 1</span><br><span class="line">second:</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>2.思路：</p>
<p>乱搞图片…</p>
<p><img src="/2020/04/08/Codeforces-Round-631-Div-2/picture2.png" alt></p>
<p>[规范解答]【感觉有点难以理解】靠……</p>
<p>我们首先考虑可能输出$-1$的情况，类似这种题目，我们先寻找可能不满足的条件，再寻找解决方案。</p>
<ul>
<li>设$m$次涂色的单元格长度之和$sum$ ，当$sum &lt; n$时，显然不满足第二种条件，不能涂满整个单元格长条。</li>
<li>对任意$i$,要满足$l_i + i - 1 &gt; n$，即如果$n - l_i &lt; i - 1$，那么我们进行完$i$次操作后，只有$n - l_i$个单元格没有被第$i$中颜色着色。所以进行完之后，至少$i - 1$种以前的颜色会消失。</li>
</ul>
<p>我们要找到的就是涂色的位置$pos$。</p>
<p>[贪心做法]</p>
<p>我们与上边的第一种条件一样，先加起来，如果$sum &lt; n$那么一定不成立。</p>
<p>然后我们采取一种贪心方式来涂，保证从第一次涂开始，操作尽可能小比并且涂满。</p>
<p>然后我们每一种颜色的长度缩小，这取决于$sum$的大小，然后更新$pos$和$sum$.</p>
<p>当$l_i+pos-1&gt;n$时，如果我们从$pos$开始涂色，那么颜色的末尾就会超过$n$，所以我们必须在$pos$之前涂色。</p>
<p>但我们前边的操作保证是最小解，所以该操作会覆盖掉前边的方案，不成立。</p>
<p>3.代码：</p>
<p>[做法1]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">ll p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">      <span class="keyword">if</span>(a[i] + i - <span class="number">1</span> &gt; n) &#123;</span><br><span class="line">         <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      p[i] = p[i + <span class="number">1</span>] + a[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(p[<span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="comment">//cout &lt;&lt; max((ll)i, n - p[i] + 1);</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld"</span>, <span class="built_in">max</span>((ll)i, n - p[i] + <span class="number">1</span>));<span class="comment">//玄学错误 cout wa掉</span></span><br><span class="line">      <span class="keyword">if</span>(i &lt; m) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[做法2]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, pos;</span><br><span class="line">ll sum;<span class="comment">//注意爆数据范围！！！</span></span><br><span class="line"><span class="keyword">int</span> a[maxn], ans[maxn];</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">      sum += a[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(sum &lt; n) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pos = <span class="number">1</span>;</span><br><span class="line">   sum -= n;</span><br><span class="line">   flag = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] + pos - <span class="number">1</span> &gt; n) &#123;</span><br><span class="line">         flag = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(sum &gt;= a[i]) &#123;<span class="comment">//贪心选择最小范围</span></span><br><span class="line">         sum -= a[i] - <span class="number">1</span>;</span><br><span class="line">         a[i] = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         a[i] -= sum;</span><br><span class="line">         sum = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ans[i] = pos;</span><br><span class="line">      pos += a[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; ans[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>模拟</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_Learning_Third</title>
    <url>/2020/03/21/Python-Learning-Third/</url>
    <content><![CDATA[<p>本周做Python的练习的时候，遇到了一个比较有意思的题。</p>
<a id="more"></a>
<p>题目描述如下：</p>
<p>获得输入的一个字符串$s$，以字符减号($-$)分割$s$，将其中首尾两段用加号($+$)组合后输出。</p>
<p>样例：</p>
<p><em>input</em>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice-Bob-Charis-David-Eric-Flurry</span><br></pre></td></tr></table></figure>
<p><em>output</em>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice+Flurry</span><br></pre></td></tr></table></figure>
<p>一开始看到这个题目的时候，是比较懵逼的 然后考虑了用$format$，发现并不行，因为使用”$-$”分割的部分，我们要考虑把”$-$”去掉，这时候考虑到一个函数$split()$</p>
<p>这个函数是以参数k为分割标记，然后将分割的各部分组合形成一个列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans = s.split(<span class="string">'-'</span>)</span><br></pre></td></tr></table></figure>
<p>形成的$ans$列表就是每个单词了 这样我们就好处理了 只需要依照着列表类型输出即可。</p>
<p>这里注意一下，题目中说明了是首尾字符，我们在输出的时候，最好采用以下的格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(ans[<span class="number">0</span>] + <span class="string">'+'</span> + ans[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<p>而不要去采用以下方式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(ans[<span class="number">0</span>] + <span class="string">'+'</span> + ans[<span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p>因为我们不知道具体的长度…（这里wa了一次呜呜呜~）</p>
<p>emmm就是个简单题…只是感觉比较有趣而已…hhh！溜~</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-1029-旧键盘</title>
    <url>/2020/03/19/PTA-1029-%E6%97%A7%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><blockquote>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805292322111488" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805260223102976/problems/994805292322111488</a></p>
</blockquote>
<p><strong>数据范围</strong>:</p>
<p>字符串长度小于80，且两个串非空</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7_This_is_a_test</span><br><span class="line">_hs_s_a_es</span><br></pre></td></tr></table></figure>
<p><em>Output</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7TI</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><p>我们用$string ans$,$ans$用来保存当前的“坏键” 我们考虑从$s1$的字串中，扫一遍，如果在字串$s2$没有对应的字符，并且它的大写字母也不在$ans$中时，我们把该字母添加到$ans$中。</p>
<p>这里要用到两个函数，分别是$string.find()$和$toupper()$。</p>
<ol>
<li><p>$string.find()$函数</p>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string/find" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/string/basic_string/find</a></p>
<p>用来查找给定字符序列的第一个子字符串，搜索始于$pos$，返回字串的内容或者$npos$的第一个字符的位置。【如果找不到的话】。</p>
<p>我们采用$npos$特殊值来表示找不到。该值一般表示该类型的最大值。</p>
<p>用法详见代码。</p>
</li>
<li><p>$toupper()$函数</p>
<p>将一个字符转换成大写。</p>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IOS</span><br><span class="line">   <span class="built_in">string</span> s1, s2;</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">   <span class="built_in">string</span> ans;</span><br><span class="line">   <span class="keyword">int</span> l1 = s1.length(), l2 = s2.length();</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l1; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(s2.<span class="built_in">find</span>(s1[i]) == <span class="built_in">string</span>::npos &amp;&amp; ans.<span class="built_in">find</span>(<span class="built_in">toupper</span>(s1[i])) == <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">           ans += <span class="built_in">toupper</span>(s1[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="comment">//system("pause");</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><p>无(占坑)</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>无（占坑）</p>
</blockquote>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-1028-人口普查</title>
    <url>/2020/03/18/PTA-1028-%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><blockquote>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805293282607104" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805260223102976/problems/994805293282607104</a></p>
</blockquote>
<p><strong>数据范围</strong>:</p>
<p>$0 &lt;= N &lt;= 10^5$</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">John 2001&#x2F;05&#x2F;12</span><br><span class="line">Tom 1814&#x2F;09&#x2F;06</span><br><span class="line">Ann 2121&#x2F;01&#x2F;30</span><br><span class="line">James 1814&#x2F;09&#x2F;05</span><br><span class="line">Steve 1967&#x2F;11&#x2F;20</span><br></pre></td></tr></table></figure>
<p><em>Output</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 Tom John</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><p>这个题给的输入是比较复杂的，我们在判断是否是一个合理的序列的时候，如果是按照年月日的格式依次判断的话，显然是比较复杂的。</p>
<p>我们采用结构体来存储这个生日：</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="comment">/* data*/</span></span><br><span class="line">&#125;Node;</span><br><span class="line">Node a[maxn];<span class="comment">//来存储信息</span></span><br></pre></td></tr></table></figure>
<p>我们写判断是否是一个合法生日的时候，就要写一下语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i].year &gt; <span class="number">1814</span> || (a[i].year == <span class="number">1814</span> &amp;&amp; a[i].month &gt; <span class="number">9</span>) || (a[i].year == <span class="number">1814</span> &amp;&amp; a[i].month = <span class="number">9</span> &amp;&amp; a[i].day &gt; <span class="number">6</span>) ||a[i].year &lt; <span class="number">2014</span> || (a[i].year == <span class="number">2014</span> &amp;&amp; a[i].month &lt; <span class="number">9</span>) || (a[i].year == <span class="number">2014</span> &amp;&amp; a[i].month = <span class="number">9</span> &amp;&amp; a[i].day &lt; <span class="number">6</span>) )</span><br></pre></td></tr></table></figure>
<p>并且我们在判断谁是最大生日/最小生日的时候，还要按照年月日依次判断，代码量冗余。</p>
<p>我们可以采用$string$的特性来进行比较。</p>
<p>直接把生日定义成一个$string$类型，$string$可以直接比较大小。</p>
<p>并且我们还可以进一步降低空间复杂度，我们不必开一个struct的数组类型，只需要保存当前的信息和现在当前的已经存在的最大/最小的生日名字信息即可。然后采用线性处理，没读入一个，先判断是否是一个合理的生日序列，然后我们更新当前的最大/最小生日即可。</p>
<p>比较过程可以直接采用$string$比较。【详见代码】</p>
<p>！！！坑点！！！</p>
<p>这个题最后题面说明是: </p>
<p><strong>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</strong></p>
<p>但是并没有给出一个特殊的样例，就是输出0的时候。如果没有有效的，输出0！！！并且后边不需要带空格 直接换行即可。</p>
<p>暗示：最后我们首先输出计数$cnt$, 然后我们再判断$cnt$是否为0，不为0时，输出最大最小。</p>
<p>【我觉得这就是一个傻逼题目的说明问题还有样例问题…..真的浪费时间】</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright(c)</span></span><br><span class="line"><span class="comment">* Author : tiketiskte</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* const int maxn = 1e5 + 5; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">string</span> minbirth = <span class="string">"2014/09/06"</span>, maxbirth = <span class="string">"1814/09/06"</span>;</span><br><span class="line">    <span class="built_in">string</span> minname = <span class="string">""</span>, maxname = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">string</span> temp_name = <span class="string">""</span>, temp_birth = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp_name &gt;&gt; temp_birth;</span><br><span class="line">        <span class="keyword">if</span> (temp_birth &gt;= <span class="string">"1814/09/06"</span> &amp;&amp; temp_birth &lt;= <span class="string">"2014/09/06"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (temp_birth &gt;= maxbirth)</span><br><span class="line">            &#123;</span><br><span class="line">                maxname = temp_name;</span><br><span class="line">                maxbirth = temp_birth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp_birth &lt;= minbirth)</span><br><span class="line">            &#123;</span><br><span class="line">                minname = temp_name;</span><br><span class="line">                minbirth = temp_birth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; minname &lt;&lt; <span class="string">" "</span> &lt;&lt; maxname &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><ol>
<li>一般复杂类型可以转换成字符串的问题，可以采用$STL$去解决。</li>
<li>输入输出一定要保持一致，不要$cout $和 $printf$混合使用[<strong>会发生莫名其妙的bug</strong>]</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/string/basic_string</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL入门操作</title>
    <url>/2020/03/04/MySQL%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>MySQL是一个比较常用的数据库 刚开始有诸多命令，再此处做一下记录便于理解。</p>
<a id="more"></a>
<h1 id="入门一"><a href="#入门一" class="headerlink" title="入门一"></a>入门一</h1><ul>
<li><p>查看安装的数据库支持的字符集范围：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show character set;</span><br></pre></td></tr></table></figure>
<p>最常用的当属utf-8字符集</p>
</li>
<li><p>查看当前数据库采用的字符集：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;character%&#39;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此处要进行修改MySQL的字符集设置（如不一致，查询等操作可能会出现乱码的情况）</p>
<p>有Client端，connection， results等。</p>
<p>注意！！！此处一定要先stop掉MySQL服务，再进行以下操作，否则修改过后MySQL无法正常启动。<strong>[亲测事实证明]</strong></p>
<ol>
<li><p>通过C盘中查看隐藏文件找到ProgramData 然后进入MySQL的MySQL server中，找到my.ini配置文件。</p>
</li>
<li><p>修改client 添加“default-character-set=utf8”</p>
<p><img src="/2020/03/04/MySQL%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/picture1.png" alt></p>
</li>
<li><p>修改mysqld添加“character-set-server = utf8”</p>
<p><img src="/2020/03/04/MySQL%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/picture2.png" alt></p>
</li>
</ol>
<p><strong>！！！不要按照视频讲解！！！会报错！会发生不能启动的情况！！！</strong></p>
<p>这样就修改了。</p>
<ul>
<li><p>查看当前数据库十余年的存储引擎：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%storage engine%&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前数据库刷新语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前数据库列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>更多的时候是采用一种编写脚本的形式去执行相应的命令 接下来就是通过类似windows下的批处理脚本来顺次执行文件中的命令。</p>
<p>编写脚本$test.sql$，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database junetest;</span><br><span class="line">use junetest;</span><br><span class="line">set default_storage_engine&#x3D;InnoDB;&#x2F;&#x2F;设定数据库引擎</span><br><span class="line">create table mytable(&#x2F;&#x2F;预先设计好的数据表</span><br><span class="line">name char(20),</span><br><span class="line">birth datetime</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>然后执行命令：[一般是source + 文件路径格式]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source d:&#x2F;test.sql</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/04/MySQL%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/picture3.png" alt></p>
<p>这样就创建完毕了。</p>
<h1 id="入门二"><a href="#入门二" class="headerlink" title="入门二"></a>入门二</h1><ul>
<li><p>采用另一种方式创建数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database 数据库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找当前数据库的路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;datadir&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择当前数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据库的默认字符集设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter database test DEFAULT CHARACTER SET &lt;字符集名&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据库的默认比较规则设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter database test DEFAULT COLLATE &lt;比较规则&gt;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库总结</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>记2020.2.24电脑重装后的Blog恢复</title>
    <url>/2020/02/24/%E8%AE%B02020-2-24%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E5%90%8E%E7%9A%84Blog%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="Blog恢复"><a href="#Blog恢复" class="headerlink" title="Blog恢复"></a>Blog恢复</h1><p>前几天由于数据库的问题 我重新安装了系统，但系统重装之后，我放在本地的blog发生了变化，消失了。</p>
<p>由于我不得不在PC端使用Typora来写markdown文本，所以我要重新把blog进行恢复。</p>
<p>在此记录一下，在恢复过程中，踩过的一些坑。</p>
<a id="more"></a>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>拥有保留的blog的主题文件，即放在C盘的blog整体文件夹</p>
<h1 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h1><p>我们照例下载nodejs和git等控件</p>
<p>先采用nodejs运行以下命令安装hexo等控件</p>
<p><img src="/2020/02/24/%E8%AE%B02020-2-24%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E5%90%8E%E7%9A%84Blog%E6%81%A2%E5%A4%8D/hexo_install.jpg" alt></p>
<p>然后我们可以在C盘用hexo来自动生成一个blog文件</p>
<p>命令如下：</p>
<p><img src="/2020/02/24/%E8%AE%B02020-2-24%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E5%90%8E%E7%9A%84Blog%E6%81%A2%E5%A4%8D/creat.jpg" alt></p>
<p>最后 我们要把这个上传到我们代理的Github站点，在此之前，我们要删掉原来的我们的代码库，重新创建一个代码库，然后在GitBash中我们配置用户名和邮箱</p>
<p>！！！注意！！！</p>
<p>此处的用户名不是我们的昵称 而是我们登录GitHub用的用户名！！！还有邮箱！</p>
<p>如图：</p>
<p><img src="/2020/02/24/%E8%AE%B02020-2-24%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E5%90%8E%E7%9A%84Blog%E6%81%A2%E5%A4%8D/git_configure.jpg" alt></p>
<p>现在我们只需要把原来的blog文件来替换掉当前的文件了……</p>
<p>一些图片 PDF控件 我们都在原来的文件夹里…</p>
<p>还是蛮简单的！！！</p>
<p>哈哈哈~就酱~</p>
<p>已经12：30了明天还有web课程，就先到这里辣~</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>树的同构</title>
    <url>/2020/02/24/%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给你两个相同结点个数的树,判断这两颗树是否同构。</p>
<blockquote>
<p><strong>题目链接</strong>:</p>
<p><a href="https://pintia.cn/problem-sets/15/problems/711" target="_blank" rel="noopener">https://pintia.cn/problem-sets/15/problems/711</a></p>
</blockquote>
<p><strong>数据范围</strong>:N &lt;= 10</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">A 1 2</span><br><span class="line">B 3 4</span><br><span class="line">C 5 -</span><br><span class="line">D - -</span><br><span class="line">E 6 -</span><br><span class="line">G 7 -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line">8</span><br><span class="line">G - 4</span><br><span class="line">B 7 6</span><br><span class="line">F - -</span><br><span class="line">A 5 1</span><br><span class="line">H - -</span><br><span class="line">C 0 -</span><br><span class="line">D - -</span><br><span class="line">E 2 -</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><u>同构</u>：</p>
<p><em>题目描述</em>：</p>
<p>两颗树A, B  若A能够通过若干次左右孩子的互换得到B，则称A B 两棵树同构。</p>
<p><em>离散数学描述</em>：</p>
<p>若两个树A, B 同构，当且仅当存在一个从A的结点到B的结点的  <strong>一对一</strong> 映上函数</p>
<p><strong><em>映上函数</em></strong>：<strong>从A到B的函数f称为映上的或满射的，当且仅当对每个b∈B，有元素a∈A使得f（a）=b。如果函数f是映上的，就说它是满射函数。</strong></p>
<p>即:A B为同构树，在A中，结点V和结点W相邻，则在B中，结点f(V)和结点f(W)也相邻。</p>
<p>一般对于多叉树而言,同构的判断就是计算出各个结点的度，并记录后，对可能同构的树做比较，若一一对应，则互为同构树。</p>
<p>此题目为二叉树  需要从题目描述的方式去考虑</p>
<p><strong>切入点</strong>：根节点</p>
<p>从根节点出发,依次按结点序号判断当前结点的左右子树是否相同  直到结点全部遍历完全 </p>
<p>思想：层序遍历  考虑按照<strong>结点-&gt;左子树-&gt;右子树</strong>即可  递归遍历</p>
<p><strong><em>树的遍历存储经典题目！！！</em></strong></p>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><h3 id="存储树的结构"><a href="#存储树的结构" class="headerlink" title="存储树的结构"></a>存储树的结构</h3><p>N&lt;=10  可以直接结构体数组存储  结构体成员变量有三个：<strong>当前结点  左孩子结点  右孩子结点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bintree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;<span class="comment">//当前结点的存储字符</span></span><br><span class="line">    <span class="keyword">int</span> lchild;<span class="comment">//左孩子结点的序号</span></span><br><span class="line">    <span class="keyword">int</span> rchild;<span class="comment">//右孩子结点的序号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="寻找根节点"><a href="#寻找根节点" class="headerlink" title="寻找根节点"></a>寻找根节点</h3><p>采用一种边建树边标记的做法。</p>
<p><strong><em>根节点</em></strong>：该结点不作为子结点在其他子树中出现  所以我么只需要判断某一个结点是否在其他结点的左右孩子结点中出现即可。</p>
<p><strong><em>具体做法</em></strong>：</p>
<p>读入时，用一个vis数组存储当前结点是否存在孩子结点。首先初始化为0。</p>
<p>每次读入样例存储再遍历时，判断其左右孩子结点是否为 ‘<strong>-</strong>’ ，若不为空，则在结构体数组中存储元素的ch信息，并将vis数组中对于该节点的值标记为1。</p>
<p>最后遍历vis数组，<strong>按照结点的序号开始遍历</strong>，当vis为0时，该节点即为根节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(bintree T[])</span><span class="comment">//返回当前树的根节点序号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">-1</span>;<span class="comment">//代表根节点的编号</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> i1, i2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> vis[maxn];<span class="comment">//左右子树下标进行标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar();<span class="comment">//用scanf读入一定要加空格</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c %c %c"</span>, &amp;T[i].ch, &amp;i1, &amp;i2);</span><br><span class="line">            <span class="keyword">if</span>(i1 != <span class="string">'-'</span>)<span class="comment">//如果存在左孩子</span></span><br><span class="line">            &#123;</span><br><span class="line">                T[i].lchild = i1 - <span class="string">'0'</span>;</span><br><span class="line">                vis[T[i].lchild] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T[i].lchild = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i2 != <span class="string">'-'</span>)<span class="comment">//如果存在右孩子</span></span><br><span class="line">            &#123;</span><br><span class="line">                T[i].rchild = i2 - <span class="string">'0'</span>;</span><br><span class="line">                vis[T[i].rchild] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T[i].rchild = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                root = i;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//按照结点序号遍历  找到后就立即退出即可。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断两课树是否同构"><a href="#判断两课树是否同构" class="headerlink" title="判断两课树是否同构"></a>判断两课树是否同构</h3><ul>
<li>[ ] 递归写法判断</li>
</ul>
<h4 id="树空的情况"><a href="#树空的情况" class="headerlink" title="树空的情况"></a>树空的情况</h4><p>0.若两个树均为空树时，显然同构。</p>
<p>1.若一棵树为空，另一棵树不为空，则显然不同构。</p>
<h4 id="树不为空的情况"><a href="#树不为空的情况" class="headerlink" title="树不为空的情况"></a>树不为空的情况</h4><p>0.两棵树根节点的值不同，显然不同构。</p>
<p>1.两个树的根节点的值相等，则继续比较<strong><em>左左孩子和右右孩子</em></strong>。（若都同构，则树同构）</p>
<p>2.两个树的根节点的值相等，但<strong><em>左左孩子和右右孩子</em></strong>不同构，则继续比较<strong><em>左右孩子和右左孩子</em></strong>。（若都同构，则树同构）</p>
<p>3.两个树的根节点的值相等，但<strong><em>左左孩子和右右孩子</em></strong>不同构，而<strong><em>左右孩子和右左孩子</em></strong>亦不同构，则显然不同构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_isomorphic</span><span class="params">(<span class="keyword">int</span> tree1, <span class="keyword">int</span> tree2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree1 == <span class="number">-1</span> &amp;&amp; tree2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree1 == <span class="number">-1</span> &amp;&amp; tree2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree1 != <span class="number">-1</span> &amp;&amp; tree2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T1[tree1].ch != T2[tree2].ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((is_isomorphic(T1[tree1].lchild, T2[tree2].lchild) &amp;&amp; is_isomorphic(T1[tree1].rchild, T2[tree2].rchild)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((is_isomorphic(T1[tree1].lchild, T2[tree2].rchild) &amp;&amp; is_isomorphic(T1[tree1].rchild, T2[tree2].lchild)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h2><ul>
<li><p>[ ] 0. 样例递归建树中，getchar的插入位置(在不用cin读入的情况下)</p>
</li>
<li><p>[ ] 1. vis数组中找到第一个后，直接break。（因为是按照结点的序号来查找的）</p>
</li>
<li><p>[ ] 2. 对于该题来说，题目表明序号简便后，可以将结构体中的左右孩子定义成int类型不必采用传统的递归定义。</p>
</li>
<li><p>[ ] 4. 判断同构时，不要忘记空树的情况。（建树时可直接判断然后返回-1表示此树为空）</p>
</li>
</ul>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(ch,a,b) &#123;printf(<span class="meta-string">"Data: %c Lchild: %c Rchild: %c\n"</span>, ch, a, b);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bintree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> lchild;</span><br><span class="line">    <span class="keyword">int</span> rchild;</span><br><span class="line">&#125;T1[maxn], T2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(bintree T[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">-1</span>;<span class="comment">//代表根节点的编号</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> i1, i2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> vis[maxn];<span class="comment">//左右子树下标进行标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c %c %c"</span>, &amp;T[i].ch, &amp;i1, &amp;i2);</span><br><span class="line">            <span class="keyword">if</span>(i1 != <span class="string">'-'</span>)<span class="comment">//如果存在左孩子</span></span><br><span class="line">            &#123;</span><br><span class="line">                T[i].lchild = i1 - <span class="string">'0'</span>;</span><br><span class="line">                vis[T[i].lchild] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T[i].lchild = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i2 != <span class="string">'-'</span>)<span class="comment">//如果存在右孩子</span></span><br><span class="line">            &#123;</span><br><span class="line">                T[i].rchild = i2 - <span class="string">'0'</span>;</span><br><span class="line">                vis[T[i].rchild] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T[i].rchild = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                root = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_isomorphic</span><span class="params">(<span class="keyword">int</span> tree1, <span class="keyword">int</span> tree2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree1 == <span class="number">-1</span> &amp;&amp; tree2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree1 == <span class="number">-1</span> &amp;&amp; tree2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree1 != <span class="number">-1</span> &amp;&amp; tree2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T1[tree1].ch != T2[tree2].ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((is_isomorphic(T1[tree1].lchild, T2[tree2].lchild) &amp;&amp; is_isomorphic(T1[tree1].rchild, T2[tree2].rchild)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((is_isomorphic(T1[tree1].lchild, T2[tree2].rchild) &amp;&amp; is_isomorphic(T1[tree1].rchild, T2[tree2].lchild)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root1, root2;</span><br><span class="line">    root1 = build(T1);</span><br><span class="line">    root2 = build(T2);</span><br><span class="line">    <span class="comment">//printf("#1:%d\n#2:%d\n", root1, root2);</span></span><br><span class="line">    <span class="keyword">bool</span> flag = is_isomorphic(root1, root2);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "flag 的值:" &lt;&lt; flag &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.2.16 碎碎念</title>
    <url>/2020/02/16/2020-2-16-%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p>碎碎念近期的一些东西…</p>
<a id="more"></a>
<p>在家里今天是不出门的第二十一天，自从正月初二以后我就再也没有出过楼门了</p>
<p><strong>初二的那天晚上逛的时候想的肯定是不会宅这么久……</strong></p>
<p>说实话 我也没有想到自己能够在一个地方不出门待20+天……</p>
<p>每天就是早上九点十点的起来，然后吃一点东西，就去玩…（也没有怎么写算法…好颓废）</p>
<p>然后中午不好好吃…想要睡觉..睡到三点起床才开始真正的代码时间叭…</p>
<p>线段树的专题刷完一半了…project  euler 题目不知道什么时候就突然停下了…</p>
<p>CF也总是第二天白天做…</p>
<p>晚上家长总是在催促睡觉..</p>
<p>但我总是偷偷玩手机…也不写算法…不知道为什么..就是感觉自己并没有什么很强的欲望去搞这些叭..</p>
<p>自己的初衷呢？</p>
<p>也不知道是什么时候没有把那到题目做完…</p>
<p>只记得好像是一个字符串处理就不想再继续做下去了..</p>
<p>原来我还是一个喜欢按序来的人啊…</p>
<p>遇到什么题目..总是学不会去跳过…总是和那一个题目在那里死磕到底…</p>
<p>但有时候就会渐渐放弃了…</p>
<p>前天好像是情人节  呵  那又与我有什么关系…</p>
<p>或许真的就想那句话说的 ：“时间会改变一切”…</p>
<p>或许真的只有时间才可以让我彻底忘掉叭,,,</p>
<p>生活现在就是阴阳师 CF VJ Blog了…音乐最近听了好多…</p>
<p>情人节那天，虽然现实生活中 我没有出去，但还是遇到了很多有趣的人辣..</p>
<p>一个个都是有趣的灵魂吖…..</p>
<p>真的 我相信痒痒鼠里什么人都是有的…只不过是你没有遇到而已</p>
<p>遇到了现在高二正在黑龙江正在备战高考的“小姐姐”…</p>
<p>聊到了她是她们学校的OI选手，但是可能同样是弱校出身叭…</p>
<p>或许唯一的出路也是高考…她说以后想成为一名程序员…或许以后会变成同行嘞不是</p>
<p>遇到了现在大三正在上学的“<strong>钥匙</strong>”…</p>
<p>我也不知道为什么她叫钥匙…总觉得好奇怪（甚至她在第一次说的时候，我觉得她在开车…..）</p>
<p>逃~</p>
<p>貌似是一位学习俄语的小姐姐嘞~ 当时还兴奋了好久  因为CF的俄语好烦……</p>
<p>还以为以后会有一个免费的翻译嘞…</p>
<p>现在都是Google翻译..搞过去..瞎搞一通…搞的自己好烦..看英语也不想看…</p>
<p>今天还以为是大四的老学姐…突然发现是一个大三的……</p>
<p>我笑了…哈哈哈…毕竟我都大二了啊哈哈哈~</p>
<p>遇到了一个很多有趣的人啊 …不过众人都是匆匆过客叭.</p>
<p>现在逐渐明白了最后能依靠的只有自己…..</p>
<p>今天还冲了哔哩哔哩的大会员 就是为了能够看完整的鬼灭之刃吖…</p>
<p>祢豆子好好看吖！！！</p>
<p>唉…11点了…差点忘了为什么写下这篇碎碎念…</p>
<ol>
<li><p>为了纪念我这一个星期以来发生的种种事情，遇到了有趣的人，刷了线段树专题，做了两场CF的题目（虽然都没有做完(</p>
<p>逃~~~</p>
</li>
<li><p>督促下个星期继续代码时间~并且做一下数学题辣~毕竟都快要忘光了…</p>
</li>
<li><p>最主要的还是 从下个星期开始,我就要网上上课咯~其实总感觉怪怪的..听着别人的课…和老师在群聊互动…</p>
<p>唉…不得已而为之罢了</p>
</li>
<li><p>还没有完成的任务：</p>
<ul>
<li><p>搞一下字符串的反转相关情况（STL）</p>
</li>
<li><p>懒惰标记搞一下</p>
</li>
<li><p>数学逻辑…数理基础慢慢来叭…</p>
</li>
<li><p>每天一道CF的C 希望下个星期天在写的时候 能够自己刷完7道啊…</p>
<p>…今天的C给咕咕咕辣~</p>
</li>
<li><p>…..好像还很多 哦对 做完看直播看到了葫芦娃两点了还在做毕业设计…感觉好辛苦…可能这就是985的优秀之处叭..毕竟他做的“安卓不可见控件内存泄漏的自动化检测”…我好像连Android都不会…</p>
</li>
<li><p>对了！还有18号开始的python…某天突然意识到自己应该去学一门脚本语言.</p>
<p>python还是比较好的嘛~最起码现在用的人很多…C++我觉得自己搞好就行了..毕竟以后想走算法的道路…</p>
<p>下个星期坚持每天学python 可以每天跟着MOOC！！！（希望自己能坚持下来！！！）</p>
</li>
<li><p>好了 差不多没了 剩下的占坑..想起来再说叭…</p>
</li>
</ul>
</li>
</ol>
<p><strong>虽然痛苦，满地打滚也要前进</strong></p>
<p><strong>因为 你的前方就是星辰大海啊！</strong></p>
<p><img src="/2020/02/16/2020-2-16-%E7%A2%8E%E7%A2%8E%E5%BF%B5/picture2.png" alt></p>
]]></content>
      <categories>
        <category>tiketiskte</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-2795.Billboard</title>
    <url>/2020/02/13/HDU-2795-Billboard/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>有一个$h * w$的矩形，现在要在上边放置$n$个东西。东西的宽度为$w_i$。</p>
<p>放东西的原则是：</p>
<p>1.尽可能的在上层</p>
<p>2.尽可能放在左边</p>
<p>你要输出的是这$n$个东西在这个矩形的第几行。</p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>$n, w, n$ 其中 $1 &lt;= h, w &lt;= 10^9, 1 &lt;= n &lt;= 200,000$</p>
<p>下边又有$n$行数据，表示$w_i$, $1 &lt;= w_i &lt;= 10^9$</p>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我们可以画一下样例 ，如图所示</p>
<p><img src="/2020/02/13/HDU-2795-Billboard/pictrue.png" alt></p>
<p>我们可以发现，对该矩形我们需要：</p>
<script type="math/tex; mode=display">
对其每一行剩余的长度 >= w_i中靠前的</script><p>我们先不考虑全题，我们考虑局部。</p>
<p>对于区间$[l, r]$来说，左半边的最大值是$l_x$, 右半边的最大值是$r_x$。</p>
<ol>
<li>如果一边是$&gt;= w$，另一边不符合。我们直接选择即可。</li>
<li>如果两边都$&lt;w$，那么我们可以直接输出$-1$。</li>
<li>如果两边都$&gt;= w$,我们左右都可以放置，这样我们可以根据题目中的要求，选择左边。</li>
</ol>
<p>简而言之，我们对于每一个$w_i$来说，都尽可能选择$h$较小且优先选择左边的。</p>
<p>询问的数据在$2*10^5$，$h$和$w$的范围是$1 &lt;= h, w &lt;= 10^9$，我们可以用线段树来维护这个矩形中每一行剩余的最大面积，对于每一个$w_i$,我们找到一个正确的行给它，并且用$ans$数组来记录所对应的行数。</p>
<p>我们可以搜改一体，找到之后，就修改这一行的最大面积(即结点存储的值)，并返回其位置。</p>
<p>现在就剩下最后一个问题了 对于数组空间 我们应该取什么样的值……</p>
<p>是根据$h$的范围，还是根据$n$的范围</p>
<p>我们看一下两个变量的范围 :</p>
<script type="math/tex; mode=display">
h:1 <= h <= 10^9\\
n :1 <= n <= 2 * 10^5</script><p>显然直接根据n的范围开数组一定会爆，我们考虑一下，</p>
<p>如果每行一个$w_i$,这样有可能高度达到$n$。那么最多也只有$2 * 10^5$个。</p>
<p>所以我们再开线段树空间的时候，最大开四倍的$n$即可。</p>
<p>我们建立的时候，直接比较$max(h, n)$即可。根据大的那一个建树。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200000</span> + <span class="number">2</span>;</span><br><span class="line">ll h, w, n;</span><br><span class="line">ll row;</span><br><span class="line">ll d[maxn &lt;&lt; <span class="number">2</span>], ans[maxn];<span class="comment">//ans数组用来记录行数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[rt] = <span class="built_in">max</span>(d[rt &lt;&lt; <span class="number">1</span>], d[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        d[rt] = w;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    build(m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//v要更新的占用空间</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="comment">//找到合适的行数就是l</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[rt] &gt;= v)<span class="comment">//要考虑n == 1的情况！</span></span><br><span class="line">        &#123;</span><br><span class="line">            d[rt] -= v;</span><br><span class="line">            ans[row++] = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans[row++] = <span class="number">-1</span>;<span class="comment">//当n 为1 时，没位置就存储1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(d[rt] &gt;= v)<span class="comment">//左右递归寻找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[rt &lt;&lt; <span class="number">1</span>] &gt;= v)<span class="comment">//递归尽量寻找上边的</span></span><br><span class="line">            update(v, l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            update(v, m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans[row++] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; h &gt;&gt; w &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(h &gt; n)</span><br><span class="line">            h = n;</span><br><span class="line">        build(<span class="number">1</span>, h, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            update(x, <span class="number">1</span>, h, <span class="number">1</span>);<span class="comment">//单点更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol>
<li><p>单点更新时变量的变化逻辑关系</p>
</li>
<li><p>搜改一体的具体操作细节见代码</p>
</li>
<li><p>提供一个构造特例：</p>
<p><strong>input</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 2 1</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p><strong>output</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Kuangbin专题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1754.I Hate It</title>
    <url>/2020/02/13/HDU-1754-I-Hate-It/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>线段树裸题</p>
<p>单点更新即可。</p>
<a id="more"></a>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line">ll N, M, a[maxn], d[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> _a, _b;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[p] = <span class="built_in">max</span>(d[p &lt;&lt; <span class="number">1</span>], d[p &lt;&lt; <span class="number">1</span> |<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        d[p] = a[l];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(l, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        build(m + <span class="number">1</span>, r, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        push_up(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        d[p] = v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= m)</span><br><span class="line">            update(x, v, l, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            update(x, v, m + <span class="number">1</span>, r, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        push_up(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; R &gt;= r)</span><br><span class="line">        <span class="keyword">return</span> d[p];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, query(L, R, l, m, p &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(R &gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, query(L, R, m + <span class="number">1</span>, r, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(M--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'Q'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; _a &gt;&gt; _b;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; query(_a, _b, <span class="number">1</span>, N, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'U'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; _a &gt;&gt; _b;</span><br><span class="line">                update(_a, _b, <span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol>
<li>多组数据….一坑点…</li>
</ol>
]]></content>
      <categories>
        <category>Kuangbin专题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1166.敌兵布阵</title>
    <url>/2020/02/13/HDU-1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>线段树裸题</p>
<p>单点更新即可。</p>
<a id="more"></a>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50000</span> + <span class="number">5</span>;</span><br><span class="line">ll T, N, a[maxn], d[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> _a, _b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[p] = d[p &lt;&lt; <span class="number">1</span>] + d[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        d[p] = a[l];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(l, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        build(m + <span class="number">1</span>, r, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        push_up(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        d[p] += v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= m)</span><br><span class="line">            update(x, v, l, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            update(x, v, m + <span class="number">1</span>, r, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        push_up(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(L &lt;= l &amp;&amp; R &gt;= r)</span><br><span class="line">    <span class="keyword">return</span> d[p];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += query(L, R, l, m, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(R &gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += query(L, R, m + <span class="number">1</span>, r, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; Case &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        build(<span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; str &amp;&amp; str[<span class="number">0</span>] != <span class="string">'E'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; _a &gt;&gt; _b;</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; query(_a, _b, <span class="number">1</span>, N, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'A'</span>)</span><br><span class="line">                update(_a, _b, <span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'S'</span>)</span><br><span class="line">                update(_a, -_b, <span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol>
<li>$build$中的赋值，$l == r$的具体含义</li>
<li>$update$中对于$l = = r$的操作</li>
<li>$query$函数中$flag$或$ans$的赋值</li>
<li>多组数据的话 注意要$memset$相关数组。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.cnblogs.com/Yokel062/p/11352683.html" target="_blank" rel="noopener">https://www.cnblogs.com/Yokel062/p/11352683.html</a></li>
<li><a href="https://www.cnblogs.com/jason2003/p/9676729.html" target="_blank" rel="noopener">https://www.cnblogs.com/jason2003/p/9676729.html</a></li>
<li><a href="https://blog.csdn.net/huangzihaoal/article/details/81813454" target="_blank" rel="noopener">https://blog.csdn.net/huangzihaoal/article/details/81813454</a></li>
<li><a href="https://www.cnblogs.com/xenny/p/9801703.html" target="_blank" rel="noopener">https://www.cnblogs.com/xenny/p/9801703.html</a></li>
<li><a href="https://blog.csdn.net/zearot/article/details/52280189" target="_blank" rel="noopener">https://blog.csdn.net/zearot/article/details/52280189</a></li>
</ol>
<p>一个非常好的线段树模板可以参考，据说是某位神牛所写</p>
<p><a href="https://www.cnblogs.com/Destiny-Gem/articles/3875243.html" target="_blank" rel="noopener">https://www.cnblogs.com/Destiny-Gem/articles/3875243.html</a></p>
]]></content>
      <categories>
        <category>Kuangbin专题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>7.10001st prime</title>
    <url>/2020/02/12/7-10001st-prime/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>By listing the first six prime numbers:$2,3, 5, 7, 11$,and $13$, we can see that the $6th$ prime is $13$.</p>
<p>What is the $10 001$st prime number?</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>我采用的是从第一个素数开始判断，如果是素数的话，就对$cnt$ 进行$+1$操作，直到$cnt == 100001$的时候为止。写一个是否为素数的判断函数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> i, cnt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt; maxn)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(isprime(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样我们可以采用一种筛法来构建一个素数表，主要是空间要开多少，这里有一个大概的公式:</p>
<p>用$π(x)$表示不超过x的素数个数，当x足够大时，存在</p>
<script type="math/tex; mode=display">
π(x)≈x/(lnx-1.08366)</script><p>具体见百科(虽然我觉得没什么用…)</p>
<p><a href="https://baike.baidu.com/item/质数/263515?fr=aladdin#5" target="_blank" rel="noopener">https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fr=aladdin#5</a>(<a href="https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fr=aladdin#5" target="_blank" rel="noopener">https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fr=aladdin#5</a>)</p>
<p><a href="https://tieba.baidu.com/p/5247968036?red_tag=3211065356" target="_blank" rel="noopener">https://tieba.baidu.com/p/5247968036?red_tag=3211065356</a></p>
<p><a href="https://blog.csdn.net/qq_40513792/article/details/95597027" target="_blank" rel="noopener">https://blog.csdn.net/qq_40513792/article/details/95597027</a></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>无</p>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><script type="math/tex; mode=display">
Answer:    104743</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3><div class="pdf" target="answer.pdf" height></div>]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>6.Sum square difference</title>
    <url>/2020/02/12/6-Sum-square-difference/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>The sum of the squares of the first ten natural numbers is,</p>
<script type="math/tex; mode=display">
1^2+2^2+...+10^2=385</script><p>The square of the sum of the first ten natural numbers is,</p>
<script type="math/tex; mode=display">
(1+2+...+10)^2=55^2=3025</script><p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025−385=2640$.</p>
<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>emmm……</p>
<p>第一次遇到这么简单的题目？</p>
<p>我们可以直接遍历到$100$即可求出两个值$sum1$和$sum2$，然后根据题意输出即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll suma, sumb;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        suma += i * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; suma &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sumb += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; sumb &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sumb * sumb - suma &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案给出了一种推导$F(n)$的解法，可以在${O(1)}$时间里求得…</p>
<p>可以参考(虽然我觉得直接$100$暴力就可以…..)</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>无</p>
<p>注意精度问题就行了 最好采用<strong>long long</strong> 来定义变量..避免发生上一种题目的情况。。。</p>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><script type="math/tex; mode=display">
Answer:25164150</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3><div class="pdf" target="answer.pdf" height></div>]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>5.Smallest multiple</title>
    <url>/2020/02/12/5-Smallest-multiple/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>$2520$ is the smallest number that can be divided by each of the numbers from $1$ to $10$ without any remainder.</p>
<p>What is the smallest positive number that is <u>evenly divisible</u> by all of the numbers from $1$ to $20$?</p>
<p> <strong>evenly divisible</strong>:  divisible with no remainder</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>数学解法：</p>
<p>题意的意思让你求一个能被$1$ ~ $20$ 都能整除的一个整数。</p>
<p>我们最直接的想法就是去找$1$ ~ $20$ 的最小公倍数。</p>
<p>欧几里得算法求出即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a % b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    <span class="keyword">int</span> flag = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        flag = a[i] / gcd(a[i], flag) * flag;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考资料可参考:（有关于数论的基本问题）</p>
<ul>
<li><p><a href="https://blog.csdn.net/leimingfu/article/details/97244935" target="_blank" rel="noopener">https://blog.csdn.net/leimingfu/article/details/97244935</a></p>
</li>
<li><p><a href="https://blog.csdn.net/NJU_Flepped/article/details/76270241" target="_blank" rel="noopener">https://blog.csdn.net/NJU_Flepped/article/details/76270241</a></p>
</li>
</ul>
<p>我们可以采用暴力的方案得出结果 因为数据量只有20 ，我们可以用对$i$ 和$j$ 遍历寻找一个$i$满足对$1$ ~$20$都满足整除方案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span> ; j &lt;= <span class="number">20</span>; j++)</span><br><span class="line">     &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//flag的判断放到i循环中</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>在求解最小公倍数的时候,有定理：</p>
<script type="math/tex; mode=display">
x、y 两个数的最小公倍数乘以它们的最大公约数等于 x 和 y 本身的乘积</script><p>故存在公式:</p>
<script type="math/tex; mode=display">
LCM(x,y)=x/GCD(x,y)*b</script><p>但计算过程中不能写成：</p>
<script type="math/tex; mode=display">
LCM(x,y)=(x*y)/GCD(x,y)</script><p>会存在$x * y$的精度溢出。</p>
<p>打表程序如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a % b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    ll flag1 = a[<span class="number">1</span>];</span><br><span class="line">    ll flag2 = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag1 = (a[i] * flag1) / (gcd(a[i], flag1));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"#对flag1"</span> &lt;&lt; <span class="string">"-----"</span> &lt;&lt; i &lt;&lt; <span class="string">"####"</span> &lt;&lt; flag1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag2 = a[i] / gcd(a[i], flag2) * flag2;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"#对flag2"</span> &lt;&lt; <span class="string">"-----"</span> &lt;&lt; i &lt;&lt; <span class="string">"####"</span> &lt;&lt; flag2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n%lld\n"</span>,flag1, flag2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>我吐了….</strong></p>
<p>最后出现了精度溢出…</p>
<p>在 $flag * 20$的时候……</p>
<p><img src="/2020/02/12/5-Smallest-multiple/picture.PNG" alt></p>
</li>
</ol>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><script type="math/tex; mode=display">
Answer:    232792560</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3><div class="pdf" target="answer.pdf" height></div>]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>4.Largest palindrome product</title>
    <url>/2020/02/11/4-Largest-palindrome-product/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is $9009 = 91 × 99$.</p>
<p>Find the largest palindrome made from the product of two 3-digit numbers.</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>1.</p>
<p>题意就是让你找一个最大回文数 ，是由两个三位数乘积可得到的。</p>
<p>（这编程题嘛~）</p>
<p>我们这里采用了两个函数,一个是$itoa$函数， 另一个是$strrev$，两个都是非标准$C/C++$库中的函数。</p>
<ul>
<li><p>$itoa$：一个把整数转换成为字符串的函数。</p>
<p>在头文件$cstdlib$中 用法如下：</p>
<script type="math/tex; mode=display">
char *itoa (int value, char *str, int base )\\
返回一个转换后的字符串指针\\
value:要被转换的整数\\
str:转换后的字符串\\
base:转换的进制数</script></li>
<li><p>$strrev$：将字符串中的字符按照逆序进行反转。</p>
<p>在头文件$cstring$中，用法如下：</p>
<script type="math/tex; mode=display">
char *strrev(char *s)\\
返回逆转后的字符串指针\\
s:要逆序的字符串</script></li>
</ul>
<p><strong>注意</strong>：此处判断的时候 一定要遍历字符串判断 不然会出现$5675-&gt;5765$这种情况 ！</p>
<p>这样我们从999开始 对$i j$ 进行$i * j$判断是不是回文数，如果是最大的，输出即可</p>
<p>（我们这里用两个参数$ans$和$solve$保存一下，其中需要记录当前最大的回文数） </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//10000--998001</span></span><br><span class="line"><span class="keyword">int</span> ans, solve = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_palindrome_number</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">10</span>], str[<span class="number">10</span>];</span><br><span class="line">    itoa(x, str, <span class="number">10</span>);</span><br><span class="line">    itoa(x, temp, <span class="number">10</span>);</span><br><span class="line">    strrev(temp);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; temp &lt;&lt; endl &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp[i] != str[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">999</span>; i &gt;= <span class="number">100</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">999</span>; j &gt;= <span class="number">100</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = i * j;</span><br><span class="line">            <span class="keyword">if</span>(is_palindrome_number(ans) &amp;&amp; ans &gt; solve)</span><br><span class="line">            &#123;</span><br><span class="line">                solve = ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.</p>
<p>数学方法就是用取模去判断三位数是不是一样的</p>
<p>可参考:<a href="https://www.cnblogs.com/zhouyinhui/archive/2011/01/14/1935824.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhouyinhui/archive/2011/01/14/1935824.html</a></p>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><script type="math/tex; mode=display">
Answer:906609</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3>   <div class="pdf" target="answer.pdf" height></div>]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>3.Largest prime factor</title>
    <url>/2020/02/10/3-Largest-prime-factor/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>The prime factors of $13195$ are $5$,$7$,$13$ and $29$.</p>
<p>What is the largest prime factor of the number $600851475143$?</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ol>
<li><p>题意是找到$600851475143$的最大质因子</p>
<p>例如 ：45可以分解成</p>
<script type="math/tex; mode=display">
45 = 3 * 3 * 5</script><p>它的质因子就是3，5  即45的最大质因子就是5</p>
<p>我们可以将其表示为该过程:</p>
<ul>
<li><p>遍历自然数(从$2$开始)，若$n$能够被$k$整除，则重复整除它，直到不能除尽为止。</p>
<p>然后再用$k + 1$ 重复上述操作</p>
</li>
</ul>
<p>例如：$45$除以$2$整除不了 则$45$ 除以$3$ 得到$15$ $15$ 再除以$3$得到$5$，$5$除以$4$无法整除，则$5$除以$5$得到$1$ 则循环结束。 </p>
</li>
</ol>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//！long long表示 int会溢出</span></span><br><span class="line"><span class="keyword">const</span> ll ans = <span class="number">600851475143</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll factor = <span class="number">2</span>;<span class="comment">//从2开始除嘛~</span></span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % factor == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, factor);<span class="comment">//选取最后一个即可</span></span><br><span class="line">            n /= factor;</span><br><span class="line">        &#125;</span><br><span class="line">        factor++;</span><br><span class="line">        <span class="comment">//此处可以优化为:factor += (factor == 2 ? 1 : 2)</span></span><br><span class="line">        <span class="comment">//因为素数除了2之外都是奇数</span></span><br><span class="line">        <span class="comment">//也就是从2 -&gt; 3 时加1 其余时候都加2</span></span><br><span class="line">        <span class="comment">//补充:当factor的平方大于n时，必定只有n这一个因子。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    solve(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>数学解法：</p>
<p>我们可以考虑一个定理：</p>
<p><strong>算数基本定理：</strong></p>
<script type="math/tex; mode=display">
任何一个大于1的自然数N，如果N不为质数，那么N可以唯一分解成有限个质数的乘积\\
即：N = P_1 * P_2 *P_3 ......*P_n  (其中P_1 < P_2<P_3 ......<P_n)</script><p>根据题意我们可以知道我们要计算的就是$P_n$</p>
<p>我们首先找到 对于N来说的一个最小质数因子 即$P_1$，然后我们再对于$N$来说，去除$P_1$,依次往下。最后当$P_x = P_n$时，得到的$P_x$ 就是最大的质因子。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>//1e8 不能采用素数筛<br>const ll ANS = 600851475143;<br>ll isprime(ll x)<br>{<br>    for(ll i = 2; ; i++)<br>    {<br>        if(x % i == 0)<br>            return i;<br>    }<br>}<br>int main(void)<br>{<br>    IOS<br>    ll prime_number = ANS;<br>    ll min_prime_number = isprime(prime_number);<br>    while(min_prime_number != prime_number)<br>    {<br>        prime_number /= min_prime_number;<br>        min_prime_number = isprime(prime_number);<br>    }<br>    cout &lt;&lt; prime_number &lt;&lt; endl;<br>    return 0;<br>}<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   ### 注意点</span><br><span class="line"></span><br><span class="line">1. 不可以采用素数筛 会超时。</span><br><span class="line">2. 以下代码从3开始  某种程度来说 不够严谨 但求的时$P_n$故可得到正确结果。</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;C++</span><br><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1e8 不能采用素数筛</span><br><span class="line">const ll ANS &#x3D; 600851475143;</span><br><span class="line">ll isprime(ll x)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i &#x3D; 3; ; i +&#x3D; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(x % i &#x3D;&#x3D; 0)</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    IOS</span><br><span class="line">    ll prime_number &#x3D; ANS;</span><br><span class="line">    ll min_prime_number &#x3D; isprime(prime_number);</span><br><span class="line">    while(min_prime_number !&#x3D; prime_number)</span><br><span class="line">    &#123;</span><br><span class="line">        prime_number &#x2F;&#x3D; min_prime_number;</span><br><span class="line">        min_prime_number &#x3D; isprime(prime_number);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; prime_number &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><script type="math/tex; mode=display">
Answer:6857</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3>   <div class="pdf" target="answer.pdf" height></div>]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Rhythmical</tag>
      </tags>
  </entry>
  <entry>
    <title>2.Even Fibonacci numbers</title>
    <url>/2020/02/10/2-Even-Fibonacci-numbers/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>
<script type="math/tex; mode=display">
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</script><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ol>
<li><p>一开始想的是我们可以直接写出对于前400万项的Fibonacci数列。</p>
<p>然后判断每一项是否是偶数 再<strong>sum</strong>一下。 </p>
<script type="math/tex; mode=display">
Fibonacci(n) = Fibonacci(n- 1) + Fibonacci(n - 2)</script><p>时间复杂度：${O(2n)}$  </p>
<p>不过可以采用乘方优化达到${O(\log n + n)}$ 的复杂度</p>
<p>可参考：<a href="https://www.cnblogs.com/AlvinZH/p/7637094.html" target="_blank" rel="noopener">https://www.cnblogs.com/AlvinZH/p/7637094.html</a></p>
<p><strong>BUT</strong> ：这种做法在400w情况下仍然爆了。</p>
</li>
</ol>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4000000</span>;</span><br><span class="line">ll Fibonacci[maxn];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    Fibonacci[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    Fibonacci[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= maxn; i++)</span><br><span class="line">        Fibonacci[i] = Fibonacci[i - <span class="number">1</span>] + Fibonacci[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Fibonacci[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            ans += Fibonacci[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>数学解法：</p>
<p>我们观察到 ，题目中只是让求出Fibonacci数列的偶数项之和，我们能否找到一个关于Fibonacci数列偶数项前${n}$项和的递推公式~</p>
<p>观察题目中给的Fibonacci偶数项有：</p>
<script type="math/tex; mode=display">
2，5，8，34，144，610   ...</script><p>从第三项开始有：</p>
<script type="math/tex; mode=display">
34 = 4*8+2;\\
144 = 4*34 + 8;\\
610 = 4*144+ 34 ;</script><p>所以有以下公式(对Fibonacci偶数数列)：</p>
<script type="math/tex; mode=display">
Fibonacci_e(n) = Fibonacci_e(n - 1) * 4 +Fibonacci_e(n - 2)</script><p>时间复杂度：${O(\frac{n}{2})}$[减少了一半的运算量]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4000000</span>;</span><br><span class="line">   ll Fibonacci[maxn];</span><br><span class="line">   <span class="keyword">int</span> ans;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       IOS</span><br><span class="line">       Fibonacci[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">       Fibonacci[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= maxn; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               Fibonacci[i] = <span class="number">4</span> * Fibonacci[i - <span class="number">1</span>] + Fibonacci[i - <span class="number">2</span>];</span><br><span class="line">               <span class="keyword">if</span>(Fibonacci[i] &lt; maxn)</span><br><span class="line">                   ans += Fibonacci[i];</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>判断偶数和！不是偶数个数！一开始写出SB代码…WA了</p>
<p>读题意！！！</p>
</li>
</ol>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3></li>
</ol>
<script type="math/tex; mode=display">
   Answer:4613732</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3>   <div class="pdf" target="answer.pdf" height></div>
]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Rhythmical</tag>
      </tags>
  </entry>
  <entry>
    <title>1.Multiples of 3 and 5</title>
    <url>/2020/02/09/1-Multiples-of-3-and-5/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>
<p>Find the sum of all the multiples of 3 or 5 below 1000.</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ol>
<li><p>暴力解法：</p>
<p>遍历从1 - 1000 判断一下每一个数字是不是3/5的倍数 如果是的话 就sum一下 。</p>
<p>时间复杂度：${O(n)}$</p>
</li>
</ol>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span> || i % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>数学解法：</p>
<p>（对于1 - 20）</p>
<p>观察对于3的倍数有：3 5 9 12 15 18</p>
<p>​        对于5的倍数有:    5 15 20</p>
<p><strong>！！！发现了什么！！！   盲生你发现了华点</strong></p>
<ul>
<li>对3来说：是以3为首项3为等差的等差数列</li>
<li>对5来说：是以5为首项5为等差的等差数列</li>
<li>我们再去掉以15为首项15为等差的等差数列(因为计算了两遍~)</li>
</ul>
<p>我们设要求的和为$F$，n为等差数列的和为$sum(n)$<br>有以下公式：</p>
<script type="math/tex; mode=display">
F = sum(3) + sum(5) - sum(15)</script><p>等差数列求和公式有：$sum(n) =\frac {n  *  (n+1)} {2} $</p>
<p>时间复杂度：${O(1)}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1000</span> - <span class="number">1</span>;<span class="comment">//不是1000 是999</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = maxn / x;</span><br><span class="line">    <span class="keyword">int</span> a1 = x;</span><br><span class="line">    <span class="keyword">int</span> an = a1 + (temp - <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">return</span> (a1 + an) * temp / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">3</span>) + sum(<span class="number">5</span>) - sum(<span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>边界取值取不到1000 所以计算的时候要999 否则要在得出的结果- 1000。</li>
</ol>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><script type="math/tex; mode=display">
Answer:233168</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3><div class="pdf" target="answer.pdf" height></div>
</li>
</ol>
]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Build a blog</title>
    <url>/2020/02/06/Build-a-blog/</url>
    <content><![CDATA[<h3 id="这里展示的主要是一些在blog搭建初期的遇到问题以及解决措施"><a href="#这里展示的主要是一些在blog搭建初期的遇到问题以及解决措施" class="headerlink" title="这里展示的主要是一些在blog搭建初期的遇到问题以及解决措施"></a>这里展示的主要是一些在blog搭建初期的遇到问题以及解决措施</h3><p>我使用的是hexo的blog框架</p>
<p>采用的主题是next.</p>
<a id="more"></a>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>搭建初期：</p>
<ul>
<li><p>参考：</p>
<p><a href="https://www.bilibili.com/video/av44544186?from=search&amp;seid=2420425254997109895" target="_blank" rel="noopener">https://www.bilibili.com/video/av44544186?from=search&amp;seid=2420425254997109895</a></p>
</li>
</ul>
<p>添加插件遇到的问题：</p>
<ul>
<li><p>添加图片：</p>
<p><a href="https://blog.csdn.net/u010996565/article/details/89196612" target="_blank" rel="noopener">https://blog.csdn.net/u010996565/article/details/89196612</a></p>
<p><a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p>
<p><a href="https://blog.csdn.net/lwcxy966/article/details/91363965" target="_blank" rel="noopener">https://blog.csdn.net/lwcxy966/article/details/91363965</a></p>
</li>
<li><p>创建标签和分类：</p>
<p><a href="https://blog.csdn.net/winter_chen001/article/details/79719154" target="_blank" rel="noopener">https://blog.csdn.net/winter_chen001/article/details/79719154</a></p>
<p><a href="https://blog.csdn.net/weixin_33857230/article/details/91474562" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33857230/article/details/91474562</a></p>
<p><a href="https://blog.csdn.net/ganzhilin520/article/details/79047249" target="_blank" rel="noopener">https://blog.csdn.net/ganzhilin520/article/details/79047249</a></p>
<p><a href="https://blog.csdn.net/Wonz5130/article/details/84666519" target="_blank" rel="noopener">https://blog.csdn.net/Wonz5130/article/details/84666519</a></p>
<p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93644533" target="_blank" rel="noopener">https://blog.csdn.net/mqdxiaoxiao/article/details/93644533</a></p>
</li>
<li><p>创建个人页面：</p>
<p><a href="https://www.cnblogs.com/ztoz/p/5515475.html" target="_blank" rel="noopener">https://www.cnblogs.com/ztoz/p/5515475.html</a></p>
<p><a href="https://blog.csdn.net/csdjia11/article/details/91896116" target="_blank" rel="noopener">https://blog.csdn.net/csdjia11/article/details/91896116</a></p>
</li>
<li><p>添加评论系统：</p>
<p><a href="https://blog.csdn.net/blue_zy/article/details/79071414" target="_blank" rel="noopener">https://blog.csdn.net/blue_zy/article/details/79071414</a></p>
<p><a href="https://www.cnblogs.com/yyhh/p/11058985.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyhh/p/11058985.html</a></p>
</li>
<li><p>添加PDF插件：</p>
<p><a href="http://lingr7.coding.me/2019/10/02/theme-hexo-pdf%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-%E8%A7%A3%E5%86%B3hexo-pdf%E6%96%87%E4%BB%B6%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98.html" target="_blank" rel="noopener"><a href="http://lingr7.coding.me/2019/10/02/theme-hexo-pdf使用技巧-解决hexo-pdf文件显示不全的问题.html" target="_blank" rel="noopener">http://lingr7.coding.me/2019/10/02/theme-hexo-pdf%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-%E8%A7%A3%E5%86%B3hexo-pdf%E6%96%87%E4%BB%B6%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98.html</a></a></p>
<p><a href="https://blog.csdn.net/u010820857/article/details/82356974" target="_blank" rel="noopener">https://blog.csdn.net/u010820857/article/details/82356974</a></p>
<p><a href="https://jiap.me/tutorial/how-to-post-pdf-on-website/" target="_blank" rel="noopener">https://jiap.me/tutorial/how-to-post-pdf-on-website/</a></p>
</li>
<li><p>添加二次元人物：</p>
<p><a href="https://blog.csdn.net/dataiyangu/article/details/83021854" target="_blank" rel="noopener">https://blog.csdn.net/dataiyangu/article/details/83021854</a></p>
<p><a href="https://blog.csdn.net/u011054333/article/details/82718910" target="_blank" rel="noopener">https://blog.csdn.net/u011054333/article/details/82718910</a></p>
<p><a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">https://huaji8.top/post/live2d-plugin-2.0/</a></p>
<p><a href="https://techstay.github.io/my-static-blog/2018/09/15/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E6%B7%BB%E5%8A%A0%E5%8F%AF%E7%88%B1%E7%9A%84Live-2D%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener"><a href="https://techstay.github.io/my-static-blog/2018/09/15/在Hexo博客上添加可爱的Live-2D模型/" target="_blank" rel="noopener">https://techstay.github.io/my-static-blog/2018/09/15/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E6%B7%BB%E5%8A%A0%E5%8F%AF%E7%88%B1%E7%9A%84Live-2D%E6%A8%A1%E5%9E%8B/</a></a></p>
</li>
<li><p>添加站内搜索：</p>
<p><a href="https://www.cnblogs.com/fsong/p/11759136.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsong/p/11759136.html</a></p>
</li>
<li><p>出现域名问题：</p>
<p><a href="https://github.com/xCss/Valine/issues/72" target="_blank" rel="noopener">https://github.com/xCss/Valine/issues/72</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>列出联通集</title>
    <url>/2020/01/29/%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给一个无向图  N个顶点（0 ~ N-1） E条边  从第0个顶点开始DFS/BFS遍历这个无向图</p>
<p>按照编号递增的顺序访问邻接点.</p>
<blockquote>
<p><strong>题目链接</strong>:</p>
<p><a href="https://pintia.cn/problem-sets/15/problems/714" target="_blank" rel="noopener">https://pintia.cn/problem-sets/15/problems/714</a></p>
</blockquote>
<p><strong>数据范围</strong>:</p>
<p>0 &lt;= N &lt;= 10</p>
<p>E未知</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>无（基础BFS/DFS）</p>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug &#123;printf(<span class="meta-string">"AC!!!\n"</span>);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn];<span class="comment">//无向图</span></span><br><span class="line"><span class="keyword">int</span> vis[maxn];<span class="comment">//标记该点是否访问过</span></span><br><span class="line"><span class="keyword">int</span> N, E;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; N; i1++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i1] &amp;&amp; G[x][i1])</span><br><span class="line">            DFS(i1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="keyword">int</span> flag = q.front();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; N; i1++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i1] &amp;&amp; G[flag][i1])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i1] = <span class="number">1</span>;</span><br><span class="line">                q.push(i1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; E;</span><br><span class="line">    <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        G[a][b] = <span class="number">1</span>;</span><br><span class="line">        G[b][a] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//无向图建图细节</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="comment">//DFS</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])<span class="comment">//标记访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt;"第" &lt;&lt; i &lt;&lt;"个点的DFS搜索:" &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#123; "</span>;</span><br><span class="line">            DFS(i);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#125;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[i])<span class="comment">//标记访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt;"第" &lt;&lt; i &lt;&lt;"个点的BFS搜索:" &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#123; "</span>;</span><br><span class="line">            BFS(i);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#125;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">8 6</span></span><br><span class="line"><span class="comment">0 7</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment">2 0</span></span><br><span class="line"><span class="comment">4 1</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">&#123; 0 1 4 2 7 &#125;</span></span><br><span class="line"><span class="comment">&#123; 3 5 &#125;</span></span><br><span class="line"><span class="comment">&#123; 6 &#125;</span></span><br><span class="line"><span class="comment">&#123; 0 1 2 7 4 &#125;</span></span><br><span class="line"><span class="comment">&#123; 3 5 &#125;</span></span><br><span class="line"><span class="comment">&#123; 6 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><ol>
<li><p>第一次提交的时候，获得了WA。</p>
<p>然后输出各个环节的程序，发现在queue处并没有进行执行。</p>
<p>……</p>
<p>发现没有添加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br></pre></td></tr></table></figure>
<p>这一行代码。。。。。。</p>
<p>菜死了….BFS递归遍历完后要清空标记数组再DFS。。。。。。</p>
<p>找了好久…</p>
</li>
<li><p>输出样例细节点：注意空格的位置及其按序号排列的遍历顺序换行。</p>
</li>
<li><p>BFS写的不多 要多加练习。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>kuangbin搜索专题：<a href="https://vjudge.net/article/720" target="_blank" rel="noopener">https://vjudge.net/article/720</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>Graph Theory</tag>
        <tag>BFS&amp;DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>六度空间</title>
    <url>/2020/01/29/%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给一个图，有N个结点 M条边  然后找出每一个结点从当前结点开始  与该节点距离不超过6的结点数占结点总数N的百分比.</p>
<blockquote>
<p><strong>题目链接</strong>:</p>
<p><a href="https://pintia.cn/problem-sets/15/problems/715" target="_blank" rel="noopener">https://pintia.cn/problem-sets/15/problems/715</a></p>
</blockquote>
<p><strong>数据范围</strong>:</p>
<p>N: 1 &lt; N &lt; 1e3</p>
<p>M: &lt;= 33 *N</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br></pre></td></tr></table></figure>
<p><em>Output</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: 70.00%</span><br><span class="line">2: 80.00%</span><br><span class="line">3: 90.00%</span><br><span class="line">4: 100.00%</span><br><span class="line">5: 100.00%</span><br><span class="line">6: 100.00%</span><br><span class="line">7: 100.00%</span><br><span class="line">8: 90.00%</span><br><span class="line">9: 80.00%</span><br><span class="line">10: 70.00%</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>图论遍历搜索/计数问题 可采用DFS/BFS求解。</p>
<p>对于该题，把每一个结点的交际圈看成一层，与该节点相连的所有节点都做计数，并与该节点距离小于6的节点做计数。</p>
<p>BFS/DFS的选择：</p>
<p>每一个节点 计算与其联通的所有节点，BFS较好。</p>
<p><strong>BFS模板+计数</strong></p>
<p>初始的BFS模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "#:" &lt;&lt; x &lt;&lt; "  ";</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; G[x][i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对每一个节点进行BFS</li>
<li>BFS中累计访问的节点数目</li>
<li><strong>记录“层”数，只计算六层以内的节点数目（难点：如何记录层数）</strong></li>
</ul>
<p><strong>BFS的记录层数写法详解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解释几个变量的具体含义：</span></span><br><span class="line">G[maxn][maxn]:存图</span><br><span class="line">vis[maxn]:标记该点是否被探索过</span><br><span class="line">？想一下把vis的<span class="built_in">memset</span>放到BFS里？还是main里？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先计数：BFS返回Count来计数</span></span><br><span class="line">Count：计数距离小于<span class="number">6</span>的节点</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">int</span> Count = <span class="number">1</span>;</span><br><span class="line">    q.push(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; G[x][i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Count++;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//再记录层数：</span></span><br><span class="line"><span class="comment">//关键点：如何去记录这一层已经结束并标记该下一层？</span></span><br><span class="line"><span class="comment">//ans:标记层数，从当前层数开始 -&gt; 第六层结束</span></span><br><span class="line"><span class="comment">//last:记录当前层的最后一个节点</span></span><br><span class="line"><span class="comment">//tail:记录下一层的最后一个节点</span></span><br><span class="line">最初赋值 先令last = v;</span><br><span class="line">即当前last指向该节点，然后遍历节点，压缩进队列过程中，将最后一个赋值给tail</span><br><span class="line">然后如果不为空出队过程中，如果last = 出队的节点，对last 重新赋值（下一层最后一个节点-&gt;tail）</span><br><span class="line"><span class="keyword">int</span> BFS(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">int</span> Count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> last = x;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    q.push(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; G[x][i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Count++;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">                tail = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last == x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            last = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">6</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> N, E;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));<span class="comment">//?玄幻错误 放到这里就对...</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">int</span> Count = <span class="number">1</span>;<span class="comment">//计数，是否到达第六个结点</span></span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> last = x;<span class="comment">//记录每一层的最后一个结点</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    q.push(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "#:" &lt;&lt; flag &lt;&lt; "  ";</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; G[x][i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Count++;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">                tail = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last == x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            last = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">6</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; E;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        G[a][b] = G[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sovle = BFS(i);</span><br><span class="line">        <span class="keyword">double</span> output = sovle * <span class="number">100.0</span> / N;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %.2lf%%\n"</span>, i, output);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><ol>
<li>BFS/DFS选取可以看问题是要最近/最多/最远进行选择，一般路径最短问题DFS，路径条数问题BFS.</li>
<li>memset在进行初始化中，要看数据范围，在该题，若对G进行初始化，则会发生内存超限。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ol>
<li><a href="https://www.cnblogs.com/zengguoqiang/p/8429087.html" target="_blank" rel="noopener">https://www.cnblogs.com/zengguoqiang/p/8429087.html</a></li>
<li><a href="https://blog.csdn.net/Dream_Weave/article/details/80870033" target="_blank" rel="noopener">https://blog.csdn.net/Dream_Weave/article/details/80870033</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>Graph Theory</tag>
        <tag>BFS&amp;DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>堆中的路径</title>
    <url>/2020/01/20/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定n个数（无序），将n个数插入到一个小顶堆a[i]中，然后m个询问，给定一个下标x，打印a[x]到根节点的路径</p>
<blockquote>
<p><strong>题目链接</strong>:</p>
<p><a href="https://pintia.cn/problem-sets/15/problems/713" target="_blank" rel="noopener">https://pintia.cn/problem-sets/15/problems/713</a></p>
</blockquote>
<p><strong>数据范围</strong>:</p>
<p>N, M &lt;= 1000</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="大顶堆小顶堆"><a href="#大顶堆小顶堆" class="headerlink" title="大顶堆小顶堆"></a>大顶堆小顶堆</h3><ol>
<li><p>先根据序列的输入顺序构造出一颗<strong>完全二叉树</strong>（从1开始 用数组存储）</p>
</li>
<li><p>大顶堆：arr[i + 1] &gt;= arr[2i + 1] &amp;&amp; arr[i] &gt;= arr[2i + 2]</p>
<p>小顶堆：arr[i + 1] &lt;= arr[2i + 1] &amp;&amp; arr[i] &lt;= arr[2i + 2]</p>
</li>
<li><p>建立大顶堆小顶堆的过程 == 堆排序的过程</p>
<p><u>对结点来说</u>： <strong>上浮</strong>      <strong>下沉</strong> </p>
</li>
<li><p>堆中的路径：</p>
<p><img src="/2020/01/20/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/pictrue.png" alt></p>
</li>
</ol>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createminheap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">-10001</span>;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertminheap</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length++;</span><br><span class="line">    <span class="keyword">int</span> n1 = length;</span><br><span class="line">    <span class="keyword">while</span>(arr[n1 / <span class="number">2</span>] &gt; x)<span class="comment">//把X放于最后逐个与它的父节点进行比较，很巧妙！</span></span><br><span class="line">    &#123;</span><br><span class="line">        arr[n1] = arr[n1 / <span class="number">2</span>];</span><br><span class="line">        n1 /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小顶堆的上浮操作</span></span><br><span class="line">    arr[n1] = x;<span class="comment">//链到数组最后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    createminheap();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        insertminheap(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[temp]);</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp /= <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, arr[temp]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;<span class="comment">//格式注意~</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度:O(N * logN)</span></span><br></pre></td></tr></table></figure>
<h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><ol>
<li><p>小顶堆和大顶堆的定义及构建方法。</p>
</li>
<li><p>切入点不要去直接建立一个小顶堆  题意说明要插入，而不是去建立一个最小堆</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>1.堆排序：<a href="https://www.cnblogs.com/lanhaicode/p/10546257.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanhaicode/p/10546257.html</a></p>
<p>2.小顶堆的建立：<a href="https://blog.csdn.net/fdkNeverStopLearning/article/details/81662122" target="_blank" rel="noopener">https://blog.csdn.net/fdkNeverStopLearning/article/details/81662122</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>是否同一颗二叉搜索树</title>
    <url>/2020/01/15/%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个不同的二叉搜索树，N个数，L次询问判断，判断这两个二叉搜索树是否结构一样。</p>
<blockquote>
<p><strong>题目链接</strong>:</p>
<p><a href="https://pintia.cn/problem-sets/15/problems/712" target="_blank" rel="noopener">https://pintia.cn/problem-sets/15/problems/712</a></p>
</blockquote>
<p><strong>数据范围</strong>:<br>N &lt;= 10</p>
<p>L范围不确定</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong><em>二叉搜索树</em></strong></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>BST(Binary Search tree)，可能为空树，可能是一个具有以下性质的一颗树:</p>
<ul>
<li><p>[ ] 1. 若其左子树不为空，则左子树上所有的结点的值均小于它的根节点的值；</p>
</li>
<li><p>[ ] 2. 若其右子树不为空，则右子树上所有的结点的值均大于大的根节点的值；</p>
</li>
<li><p>[ ] 3. 它的左右子树也均为二叉搜索树。</p>
</li>
</ul>
<ul>
<li>[ ] 4. 无相同键值的结点。（有争议）</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>插入 查找复杂度较低。（相对于线性数据结构来说）</p>
<p>期望：$ {O(\log n)} $</p>
<p>当序列有序时，树退化成线性表</p>
<p>最坏：${O(n)}$</p>
<h4 id="支持操作"><a href="#支持操作" class="headerlink" title="支持操作"></a>支持操作</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><blockquote>
<p>在一个二叉搜索树T中，查找值为X的结点</p>
</blockquote>
<p>查找过程：<u><strong>递归</strong></u></p>
<p>0.若T为空树，则查找失败，否则。</p>
<p>1.若X等于T的根节点的键值，则查找成功，否则。</p>
<p>2.若X小于T的根节点的键值，则查找T的左子树，否则。</p>
<p>3.查找T的右子树。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, KeyType key, BiTree f, BiTree &amp;p)</span> </span>&#123;</span><br><span class="line"><span class="comment">//在搜索二叉树T中查询键值为key的元素，p指向key元素节点，f表示查找失败时，指向T的父亲，初始调用值为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!T) &#123; <span class="comment">// 查找不成功</span></span><br><span class="line">        p = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == T-&gt;data.key) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data.key) <span class="comment">// 在左子树中继续查找</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在右子树中继续查找</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>相关联系</strong>：</p>
<p>与此题相比，没有让你查找X的值的位置，判断两个二叉搜素树是否相同，即从根节点开始遍历树T，判断每一个结点及其左右孩子是否相同，反之，则树不相同。</p>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><blockquote>
<p>向一个二叉搜索树T中，插入一个键值为X的结点。（不要破坏原有的二叉搜索树的结构特点）</p>
</blockquote>
<p>插入过程：<u><strong>递归</strong></u></p>
<p>0.若T为空树，则X的结点作为根节点插入，否则。</p>
<p>1.若X等于T的根节点的键值，则返回，否则。</p>
<p>2.若X小于T的根节点的键值，则将X的结点插入到T的左子树中，否则。</p>
<p>3.把X插入到T的右子树中。</p>
<blockquote>
<p>注：新插入的结点总是叶子节点（想一下就出来了）</p>
</blockquote>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *&amp;T, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) &#123;</span><br><span class="line">        s = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        T = s; <span class="comment">// 被插结点S为新的根结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.key == T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 关键字等于e.key的数据元素，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (e.key &lt; T-&gt;data.key)</span><br><span class="line">        InsertBST(T-&gt;lchild, e);  <span class="comment">// 将 e 插入左子树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        InsertBST(T-&gt;rchild, e);  <span class="comment">// 将 e 插入右子树</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><blockquote>
<p>在一个二叉搜索树T中，删除一个键值为X的结点。（不要破坏原有的二叉搜索树的结构特点）</p>
</blockquote>
<p>删除过程：<u><strong>递归+旋转结点</strong></u></p>
<p>0.若X结点为叶子结点，只需要修改其双亲结点的指针。</p>
<p>1.若X有左孩子结点XL<strong>或</strong>右孩子结点XR，直接令XL/XR成为删除结点的左孩子结点/右孩子结点。</p>
<p>2.若X有左孩子结点XL<strong>和</strong>右孩子结点XR，有两种做法：（规定删除结点为X 其父节点为T）</p>
<ul>
<li>令XL为T的左/右子树结点（依据X是T的左/右子树），S是XL的最右下结点，而X的右子树为S的右子树。</li>
<li>令X的直接前驱/直接后驱替代T，再直接删除X的直接前驱/直接后驱。</li>
</ul>
<blockquote>
<p>基本思路：不要去删除X，而是选择X的有序的前驱结点或者有序的后驱结点来替代X。</p>
<p>参考资料：<a href="https://en.wikipedia.org/wiki/Binary_search_tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Binary_search_tree</a></p>
</blockquote>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T, KeyType key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若二叉查找树T中存在关键字等于key的数据元素时，则删除该数据元素，并返回</span></span><br><span class="line">    <span class="comment">// TRUE；否则返回FALSE</span></span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//不存在关键字等于key的数据元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == T-&gt;data.key)   <span class="comment">//   找到关键字等于key的数据元素</span></span><br><span class="line">            <span class="keyword">return</span> Delete(T);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data.key)</span><br><span class="line">            <span class="keyword">return</span> DeleteBST(T-&gt;lchild, key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> DeleteBST(T-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree *&amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该节点为叶子节点，直接删除</span></span><br><span class="line">    BiTree *q, *s;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;rchild &amp;&amp; !p-&gt;lchild) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = <span class="literal">NULL</span>;  <span class="comment">// Status Delete(BiTree *&amp;p) 要加&amp;才能使P指向NULL</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;rchild) &#123; <span class="comment">// 右子树空则只需重接它的左子树</span></span><br><span class="line">        q = p-&gt;lchild;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        p-&gt;data = p-&gt;lchild-&gt;data;</span></span><br><span class="line"><span class="comment">        p-&gt;lchild=p-&gt;lchild-&gt;lchild;</span></span><br><span class="line"><span class="comment">        p-&gt;rchild=p-&gt;lchild-&gt;rchild;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p-&gt;data = q-&gt;data;</span><br><span class="line">        p-&gt;lchild = q-&gt;lchild;</span><br><span class="line">        p-&gt;rchild = q-&gt;rchild;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;lchild) &#123; <span class="comment">// 左子树空只需重接它的右子树</span></span><br><span class="line">        q = p-&gt;rchild;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        p-&gt;data = p-&gt;rchild-&gt;data;</span></span><br><span class="line"><span class="comment">        p-&gt;lchild=p-&gt;rchild-&gt;lchild;</span></span><br><span class="line"><span class="comment">        p-&gt;rchild=p-&gt;rchild-&gt;rchild;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p-&gt;data = q-&gt;data;</span><br><span class="line">        p-&gt;lchild = q-&gt;lchild;</span><br><span class="line">        p-&gt;rchild = q-&gt;rchild;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左右子树均不空</span></span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span> (s-&gt;rchild) &#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125; <span class="comment">// 转左，然后向右到尽头</span></span><br><span class="line">        p-&gt;data = s-&gt;data;  <span class="comment">// s指向被删结点的“前驱”</span></span><br><span class="line">        <span class="keyword">if</span> (q != p)</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;  <span class="comment">// 重接*q的右子树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;  <span class="comment">// 重接*q的左子树</span></span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, L;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">binnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binnode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binnode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;binnode, *bintree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bintreeinsert</span><span class="params">(bintree &amp;Tree, bintree &amp;temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;data &gt;= Tree-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Tree-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            bintreeinsert(Tree-&gt;rchild, temp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Tree-&gt;rchild = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;data &lt; Tree-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Tree-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            bintreeinsert(Tree-&gt;lchild, temp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Tree-&gt;lchild = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createbintree</span><span class="params">(bintree &amp;T, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        bintree temp;</span><br><span class="line">        temp = (bintree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(binnode));</span><br><span class="line">        temp-&gt;data = x;</span><br><span class="line">        temp-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(T != <span class="literal">NULL</span>)<span class="comment">//第一次判断是否为空树</span></span><br><span class="line">            bintreeinsert(T, temp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_same_binsearchtree</span><span class="params">(bintree T1, bintree T2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((T1 != <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>) || (T1 == <span class="literal">NULL</span> &amp;&amp; T2 != <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((T1 != <span class="literal">NULL</span> &amp;&amp; T2 != <span class="literal">NULL</span>) &amp;&amp; (T1-&gt;data != T2-&gt;data))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (is_same_binsearchtree(T1-&gt;lchild, T2-&gt;lchild) &amp;&amp; is_same_binsearchtree(T1-&gt;rchild, T2-&gt;rchild));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Allfree</span><span class="params">(bintree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        Allfree(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        Allfree(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; L;</span><br><span class="line">        bintree T1, T2;</span><br><span class="line">        T1 = T2 = <span class="literal">NULL</span>;<span class="comment">//不加会报错！！！</span></span><br><span class="line">        createbintree(T1, N);</span><br><span class="line">        <span class="keyword">while</span>(L--)</span><br><span class="line">        &#123;</span><br><span class="line">            T2 = <span class="literal">NULL</span>;</span><br><span class="line">            createbintree(T2, N);</span><br><span class="line">            <span class="keyword">bool</span> flag = is_same_binsearchtree(T1, T2);</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            Allfree(T2);</span><br><span class="line">        &#125;</span><br><span class="line">        Allfree(T1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><ol>
<li>一定记得建完后释放内存（删除当前树）[否则回WA on test 2]</li>
<li>main函数中T1 T2 的初始化。（代码习惯问题）</li>
<li>建树过程中第一次插入中要特判T==NULL是否为空</li>
<li><strong>free函数是释放的单个结点，释放整个树要手写函数！</strong></li>
<li>递归判断时思路要清晰，左右子树递归下去一定是&amp;&amp;（因为要左右同时成立才满足true条件）。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>1.结构体定义中的细节问题：</p>
<p><a href="https://zhidao.baidu.com/question/274601639.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/274601639.html</a></p>
<p><a href="https://blog.csdn.net/hk121/article/details/80839063" target="_blank" rel="noopener">https://blog.csdn.net/hk121/article/details/80839063</a></p>
<p>2.《算法导论》对于BST的讲解：</p>
<p><a href="https://blog.csdn.net/csdn0123zl/article/details/81253648" target="_blank" rel="noopener">https://blog.csdn.net/csdn0123zl/article/details/81253648</a></p>
<p>3.BST的Wiki百科：</p>
<p><a href="https://zh.wikipedia.org/wiki/二叉搜索树" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91</a></p>
<p><a href="https://en.wikipedia.org/wiki/Binary_search_tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Binary_search_tree</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（二）</title>
    <url>/2019/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C)/</url>
    <content><![CDATA[<p>17.编写一个算法，将带头结点的单向链表拆分成一个奇数链表和一个偶数链表，并分别输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitlinklist</span><span class="params">(Linklist &amp;l1, Linklist &amp;l2, Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l2 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    l3 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l1;</span><br><span class="line">    q = l2;</span><br><span class="line">    s = l3;</span><br><span class="line">    p = l1 -&gt; next;</span><br><span class="line">    q -&gt; next = s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;elem % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q -&gt; next = p;</span><br><span class="line">            <span class="comment">//printf("q的元素值:%d\n", q -&gt; elem);</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">            q -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;elem % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s -&gt; next = p;</span><br><span class="line">            <span class="comment">//printf("s的元素值:%d\n", s -&gt; elem);</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            s = s -&gt; next;</span><br><span class="line">            s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L1, L2, L3;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L1, n);</span><br><span class="line">    splitlinklist(L1, L2, L3);</span><br><span class="line">    outlinklist(L2);</span><br><span class="line">    outlinklist(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>18.已知一个带头结点的单链表lc={a1,b1,a2,b2….,an,bn}共２ｎ个元素，试设计一个算法将其拆分成二个带头结点的单向链表la 与lb,其中la={a1,a2,…an},lb={b1,b2,…,bn}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitlinklist</span><span class="params">(Linklist &amp;l1, Linklist &amp;l2, Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l2 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    l3 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l1;</span><br><span class="line">    q = l2;</span><br><span class="line">    s = l3;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = l1 -&gt; next;</span><br><span class="line">    q -&gt; next = s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//printf("%d\n", j);//j-1(j包含了头节点)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j - <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q -&gt; next = p;</span><br><span class="line">        <span class="comment">//printf("q的元素值:%d\n", q -&gt; elem);</span></span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        q = q -&gt; next;</span><br><span class="line">        q -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        s -&gt; next = p;</span><br><span class="line">        <span class="comment">//printf("s的元素值:%d\n", s -&gt; elem);</span></span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        s = s -&gt; next;</span><br><span class="line">        s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L1, L2, L3;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L1, n);</span><br><span class="line">    splitlinklist(L1, L2, L3);</span><br><span class="line">    outlinklist(L2);</span><br><span class="line">    outlinklist(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>19.已知二个带头结点的单向链表la 与lb,其中la={a1,a2,…an},lb={b1,b2,…,bn}， 试设计一个算法将其合并到一个带头结点的单链表lc中，且lc={a1,b1,a2,b2….,an,bn}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergerlinklist</span><span class="params">(Linklist &amp;l1, Linklist &amp;l2, Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l3 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l1-&gt;next;</span><br><span class="line">    q = l2-&gt;next;</span><br><span class="line">    s = l3;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        <span class="comment">//printf("%d ", s-&gt;elem);</span></span><br><span class="line">        s = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        s-&gt;next= q;</span><br><span class="line">        <span class="comment">//printf("%d ", s-&gt;elem);</span></span><br><span class="line">        s = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L1, L2, L3;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L1, n);</span><br><span class="line">    inlinklist(L2, n);</span><br><span class="line">    mergerlinklist(L1, L2, L3);</span><br><span class="line">    outlinklist(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20.已知单链表la={a1,a2,…an}，试编写一个算法，将la中的元素进行逆置，即la={an,an-1,…a1}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p ;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q-&gt;next = l-&gt;next;</span><br><span class="line">        l-&gt;next = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    transpose(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参考大佬解法:1.https://blog.csdn.net/v_xchen_v/article/details/53067448</span></span><br><span class="line"><span class="comment">//参考大佬解法:2.https://www.cnblogs.com/yepei/p/7120634.html</span></span><br></pre></td></tr></table></figure>
<p>21.试编写算法创建一个带头结点的单向循环链表la={a1,a2,…an}，并从指定的结点序号起输出循环链表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">special_traversal</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p;</span><br><span class="line">    p = l;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入指定的结点序号:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    special_traversal(L, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22.已知带头结点的单链表la={a1,a2,…an}，试编写一个算法将值重复的结点删除，使所得的结果表中的值均不相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_repeat</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;next-&gt;elem == p-&gt;elem)</span><br><span class="line">            &#123;</span><br><span class="line">                s = q-&gt;next;</span><br><span class="line">                q-&gt;next = s-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    delete_repeat(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>23.有一有序的单向链表（允许出现值相同的结点），试设计一个算法将值重复的结点删除，使所得的结果表中的值均不相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_order_repeat</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, q;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;elem == p-&gt;elem)</span><br><span class="line">        &#123;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    delete_order_repeat(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>24.已知一个带头结点的单链表lc中结点数据元素类型为字符型数据，主在包括二类字符（字母字符与数字字符），试设计一个算法，将lc拆分成二个链表la与lb，其中la的数据为字母字符，lb的数据为数字字符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"You Code AC!\n"</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitlinklist</span><span class="params">(Linklist &amp;l1, Linklist &amp;l2, Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l2 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    l3 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l1;</span><br><span class="line">    q = l2;</span><br><span class="line">    s = l3;</span><br><span class="line">    p = l1 -&gt; next;</span><br><span class="line">    q -&gt; next = s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(((p-&gt;elem) &gt;= <span class="string">'a'</span> &amp;&amp; (p-&gt;elem) &lt;= <span class="string">'z'</span>)||((p-&gt;elem) &gt;= <span class="string">'A'</span> &amp;&amp; (p-&gt;elem) &lt;= <span class="string">'Z'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            q -&gt; next = p;</span><br><span class="line">            debug;</span><br><span class="line">            <span class="comment">//printf("q的元素值:%c\n", q -&gt; elem);</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">            q -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((p-&gt;elem) &gt;= <span class="string">'0'</span> &amp;&amp; (p-&gt;elem) &lt;= <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s -&gt; next = p;</span><br><span class="line">            <span class="comment">//printf("s的元素值:%c\n", s -&gt; elem);</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            s = s -&gt; next;</span><br><span class="line">            s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L1, L2, L3;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    inlinklist(L1, n);</span><br><span class="line">    splitlinklist(L1, L2, L3);</span><br><span class="line">    outlinklist(L2);</span><br><span class="line">    outlinklist(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>25.设单链表的前二个结点值为均为１，从第三个结点开始，结点值为前二个结点值之各，试设计一个具有ｎ（２５＞ｎ＞＝３）个结点的单向链表，并输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fibonacci_number</span><span class="params">(<span class="keyword">int</span> arr[maxn])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[<span class="number">1</span>] = arr[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;elem = arr[i+<span class="number">1</span>];</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    fibonacci_number(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>26.从键盘上输入一串括号组成的字符串，试编写一个算法，判断所输入的括号是否匹配，如匹配输出１否则输出０</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug1(x) &#123;printf(<span class="meta-string">"%c "</span>,x);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug2 &#123;printf(<span class="meta-string">"You Code AC!\n"</span>);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *base;</span><br><span class="line">    <span class="keyword">char</span> *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;sqstack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqstack</span><span class="params">(sqstack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.base = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(sqstack &amp;s, <span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top - s.base &gt;= maxn)</span><br><span class="line">    &#123;</span><br><span class="line">        s.base = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(s.base, (s.stacksize + maxn) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        s.top = s.base + s.stacksize;</span><br><span class="line">        s.stacksize += maxn;</span><br><span class="line">    &#125;</span><br><span class="line">    *s.top++ = ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">pop</span><span class="params">(sqstack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == s.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="comment">//printf("该栈已空\n");</span></span><br><span class="line">    <span class="keyword">return</span> *--s.top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">gettop</span><span class="params">(sqstack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == s.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="comment">//printf("该栈已空\n");</span></span><br><span class="line">    <span class="keyword">return</span> *(s.top<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(sqstack &amp;s, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    push(s,str[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> flag = gettop(s);</span><br><span class="line">        <span class="keyword">switch</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                <span class="keyword">if</span>(str[i] == <span class="string">')'</span>)</span><br><span class="line">                    pop(s);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    push(s, str[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">                <span class="keyword">if</span>(str[i] == <span class="string">']'</span>)</span><br><span class="line">                pop(s);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                push(s, str[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">                <span class="keyword">if</span>(str[i] == <span class="string">'('</span> || str[i] == <span class="string">']'</span>)</span><br><span class="line">                    push(s, str[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.base == s.top)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入字符串:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt;= strlen(str); i++)</span></span><br><span class="line">        <span class="comment">//debug1(str[i]);</span></span><br><span class="line">    createsqstack(s);</span><br><span class="line">    <span class="keyword">bool</span> conclusion = match(s, str);</span><br><span class="line">    <span class="keyword">if</span>(conclusion == <span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>27.从键盘上输入一个十进制数n，试编写一个算法，将其转换成对应的ｐ进制输出（ｐ为2.8.16）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *base;</span><br><span class="line">    <span class="keyword">int</span> *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;sqstack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqstack</span><span class="params">(sqstack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.base = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(sqstack &amp;s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *s.top++ = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(sqstack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *--s.top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_stackempty</span><span class="params">(sqstack s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.base == s.top)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//代表栈为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//代表栈不为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">converison</span><span class="params">(sqstack &amp;s, <span class="keyword">int</span> n, <span class="keyword">int</span> base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        push(s, n % base);</span><br><span class="line">        n /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!is_stackempty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = pop(s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sqstack s;</span><br><span class="line">    createsqstack(s);</span><br><span class="line">    <span class="keyword">int</span> n, base;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入你要转换的数字和进制数:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;base);</span><br><span class="line">    converison(s, n, base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>28.从键盘上输入二个定长串s1与s2，试编写一个算法判断s1是否是s2的子串，如果是则输出１否则输出０</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> SString[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createstring</span><span class="params">(SString s, <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s[<span class="number">0</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = str[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printstring</span><span class="params">(SString s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s[<span class="number">0</span>]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>,s[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SString_match</span><span class="params">(SString s1, SString s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    i = j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= s1[<span class="number">0</span>] &amp;&amp; j &lt;= s2[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i] == s2[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; s2[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[maxn], str2[maxn];</span><br><span class="line">    SString s1, s2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请创建第一个定长串s1:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str1);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请创建第二个定长串s2:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str2);</span><br><span class="line">    createstring(s1, str1);</span><br><span class="line">    createstring(s2, str2);</span><br><span class="line">    <span class="comment">//printstring(s1);</span></span><br><span class="line">    <span class="comment">//printstring(s2);</span></span><br><span class="line">    <span class="keyword">bool</span> is_SString_match = SString_match(s1, s2);</span><br><span class="line">    <span class="keyword">if</span>(is_SString_match)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30.假设二叉树采用二叉链表存储结构，试设计一个算法求二叉树的叶子结点数并输出所有的叶子结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;binnode, *bintree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatbintree</span><span class="params">(bintree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch ==<span class="string">'#'</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (bintree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bintree));</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        creatbintree(T-&gt;lchild);</span><br><span class="line">        creatbintree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(bintree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        LNR(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>,T-&gt;data);</span><br><span class="line">        LNR(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leaf_node</span><span class="params">(bintree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild ==  <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        ans++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        leaf_node(T-&gt;lchild);</span><br><span class="line">        leaf_node(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    bintree T;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入二叉树的节点数目:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    creatbintree(T);</span><br><span class="line">    leaf_node(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"叶子结点数目:%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>31.假设二叉树采用二叉链表存储结构，试设计一个算法求二叉树的高度并给出指定结点的所在的层数（高度）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;binnode, *bintree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatbintree</span><span class="params">(bintree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch ==<span class="string">'#'</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (bintree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bintree));</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        creatbintree(T-&gt;lchild);</span><br><span class="line">        creatbintree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(bintree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        LNR(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>,T-&gt;data);</span><br><span class="line">        LNR(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(bintree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, <span class="built_in">max</span>;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">height</span>(T-&gt;lchild);</span><br><span class="line">        b = <span class="built_in">height</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">max</span> = a &gt; b ? a : b;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">max</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">finddeep</span><span class="params">(bintree T, <span class="keyword">char</span> s, <span class="keyword">int</span> ans,<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;data = s)</span><br><span class="line">        &#123;</span><br><span class="line">            x = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        finddeep(T-&gt;lchild, s, ans, x);</span><br><span class="line">        finddeep(T-&gt;rchild, s, ans, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> s;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    bintree T;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入二叉树的节点数目:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    creatbintree(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树的高度:%d\n"</span>,<span class="built_in">height</span>(T));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"AC!!!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入结点值:\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;s);</span><br><span class="line">    finddeep(T, s,<span class="number">0</span>,x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"结点值的:%d\n"</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>class work</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（一）</title>
    <url>/2019/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)/</url>
    <content><![CDATA[<p>1.已知顺序表L的长度为n，试编写算法实现在顺序表中删除值为elem的数据元素（其中n与elem从键盘输入）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + l.length; p++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletesqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; l.length &amp;&amp; l.arr[i] != elem)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; l.length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l.arr[j] != elem)</span><br><span class="line">        &#123;</span><br><span class="line">            l.arr[i++] = l.arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, elem;</span><br><span class="line">    sqlist L;</span><br><span class="line">    createsqlist(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n个元素:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    insqlist(L, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入删除的元素值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;elem);</span><br><span class="line">    deletesqlist(L, elem);</span><br><span class="line">    outsqlist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2.已知顺序表L长度为n，试编写算法实现在顺序表中值为elem的数据元素的后面插入一个值为key的数据元素（其中n、elem与key从键盘输入且顺序表的数据元素的值互不相同）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + l.length; p++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertsqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> elem, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + l.length; p++)</span><br><span class="line">        <span class="keyword">if</span>(*p == elem)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = p - l.arr;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr + l.length; p &gt;= l.arr + flag + <span class="number">1</span>; p--)</span><br><span class="line">        *(p + <span class="number">1</span>) = *p;</span><br><span class="line">    l.arr[flag + <span class="number">1</span>] = key;</span><br><span class="line">    l.length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, elem, key;</span><br><span class="line">    sqlist L;</span><br><span class="line">    createsqlist(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n个元素:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    insqlist(L, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要插入后边的元素的值和插入的元素值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;elem, &amp;key);</span><br><span class="line">    insertsqlist(L, elem, key);</span><br><span class="line">    outsqlist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.已知顺序表{a0,a1,a2,…,an-1}，且每个元素都是不相同的,试设计一个算法把所有的奇数移到所有的偶数的前面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + l.length; p++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *i = l.arr;</span><br><span class="line">    <span class="keyword">int</span> *j = l.arr + l.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((*i) % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">//偶数</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span>((*j) % <span class="number">2</span> == <span class="number">1</span>)<span class="comment">//奇数</span></span><br><span class="line">            j--;</span><br><span class="line">        <span class="comment">//printf("%d  %d",*i, *j);</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    sqlist L;</span><br><span class="line">    createsqlist(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n个元素:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    insqlist(L, n);</span><br><span class="line">    change(L);</span><br><span class="line">    outsqlist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.已知二个集合la与lb,采用顺序结构存储，其中la={a1,a2,…an},lb={b1,b2,…,bｍ}， 试设计一个算法将其合并到一个顺序表lc中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l.arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, l.arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merger</span><span class="params">(sqlist &amp;l1, sqlist &amp;l2, sqlist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1.length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l3.arr[i] = l1.arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l3.length = l1.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l2.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l3.arr[i + l1.length] = l2.arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l3.length += l2.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    sqlist  L1, L2, L3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n和m的值来创建两个顺序表:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    createsqlist(L1);</span><br><span class="line">    createsqlist(L2);</span><br><span class="line">    createsqlist(L3);</span><br><span class="line">    insqlist(L1, n);</span><br><span class="line">    insqlist(L2, m);</span><br><span class="line">    merger(L1, L2, L3);</span><br><span class="line">    outsqlist(L3);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.已知一个顺序表la，其中la={a1,a2,…an}， 试设计一个算法将其从小到大进行排序 ，再输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l.arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, l.arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l.length - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l.arr[j] &gt; l.arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//int temp = l.arr[j];</span></span><br><span class="line">                <span class="comment">//l.arr[j] = l.arr[j + 1];</span></span><br><span class="line">                <span class="comment">//l.arr[j + 1] = temp;</span></span><br><span class="line">                swap(l.arr[j], l.arr[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    sqlist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    createsqlist(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n的值来创建一个顺序表:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    insqlist(L, n);</span><br><span class="line">    sortsqlist(L);</span><br><span class="line">    outsqlist(L);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.已知二个顺序la与lb，其中la={a1,a2,…an}，lb={b1,b2,…bm}， 试设计一个算法将它们合并到顺序表lc中，且lc仍然有序，再输出 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l.arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, l.arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merger</span><span class="params">(sqlist &amp;l1, sqlist &amp;l2, sqlist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1.length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l3.arr[i] = l1.arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l3.length = l1.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l2.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l3.arr[i + l1.length] = l2.arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l3.length += l2.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l.length - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l.arr[j] &gt; l.arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//int temp = l.arr[j];</span></span><br><span class="line">                <span class="comment">//l.arr[j] = l.arr[j + 1];</span></span><br><span class="line">                <span class="comment">//l.arr[j + 1] = temp;</span></span><br><span class="line">                swap(l.arr[j], l.arr[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    sqlist  L1, L2, L3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n和m的值来创建两个顺序表:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    createsqlist(L1);</span><br><span class="line">    createsqlist(L2);</span><br><span class="line">    createsqlist(L3);</span><br><span class="line">    insqlist(L1, n);</span><br><span class="line">    insqlist(L2, m);</span><br><span class="line">    merger(L1, L2, L3);</span><br><span class="line">    sortsqlist(L3);</span><br><span class="line">    outsqlist(L3);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.设计一个算法，以先进先出的方式创建一个带头结点的单向链表，并输出 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.设计一个算法，以后进先出的方式创建一个带头结点的单向链表，并输出 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Linklist  p;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        p-&gt;next = l-&gt;next;</span><br><span class="line">        l-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9.设计一个算法，以先进先出的方式创建一个带头结点的双向链表，并输出 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist  p, s;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    l -&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    s = l;</span><br><span class="line">    p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        p-&gt;prior = s;</span><br><span class="line">        s = p;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10.设计一个算法，以后进先出的方式创建一个带头结点的双向链表，并输出 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist  p;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    l -&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">    p-&gt;next = l-&gt;next;</span><br><span class="line">    l-&gt;next = p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        p -&gt; next = l -&gt; next;</span><br><span class="line">        l -&gt; next -&gt; prior = p;</span><br><span class="line">        l -&gt; next = p;</span><br><span class="line">        p -&gt; prior = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11.已知一个(head)单链表la，其中la={a1,a2,…an}， 试设计一个算法将其中从小到大进行排序 ，再输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortlinklist</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, s;<span class="comment">//记录i 跟踪</span></span><br><span class="line">    s = p = l-&gt;next;</span><br><span class="line">    <span class="comment">//p = l-&gt;next;</span></span><br><span class="line">    <span class="comment">//s = l-&gt;next;</span></span><br><span class="line">    <span class="keyword">while</span>(s)<span class="comment">//表示前边的节点i</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = s;</span><br><span class="line">        <span class="keyword">while</span>(p)<span class="comment">//表示后边的节点i + 1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s-&gt;elem &gt; p-&gt;elem)</span><br><span class="line">                swap(s-&gt;elem,p-&gt;elem);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    sortlinklist(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>12.已知二个单链表有序链表la与lb，其中la={a1,a2,…an}，lb={b1,b2,…bm}， 试设计一个算法将它们合并到单链表lc中，且lc仍然有序，再输出 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Linklist &amp;a, Linklist &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;next = a;</span><br><span class="line">    s = a;</span><br><span class="line">    a = a-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergerlinklist</span><span class="params">(Linklist &amp;l1, Linklist &amp;l2, Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l1-&gt;next;</span><br><span class="line">    q = l2-&gt;next;</span><br><span class="line">    l3 = s = l1;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;elem &lt; q-&gt;elem)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//s-&gt;next = p;</span></span><br><span class="line">            <span class="comment">//s = p;</span></span><br><span class="line">            <span class="comment">//p = p-&gt;next;</span></span><br><span class="line">            swap(p,s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//s-&gt;next = q;</span></span><br><span class="line">            <span class="comment">//s = q;</span></span><br><span class="line">            <span class="comment">//q = q-&gt;next;</span></span><br><span class="line">            swap(q,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p ? p : q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L1, L2, L3;</span><br><span class="line">    <span class="keyword">int</span>  n, m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L1, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建m个元素的链表的m值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    inlinklist(L2, m);</span><br><span class="line">    mergerlinklist(L1, L2, L3);</span><br><span class="line">    outlinklist(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>13.设计一个算法实现在带头结点的单向链表中删除给定值的结点。（链表中的数据元素值均不相同）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletelinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, s;</span><br><span class="line">    <span class="comment">//p = l;</span></span><br><span class="line">    <span class="comment">//s = l; 若没有 则无法删除链表第一个元素</span></span><br><span class="line">    p = s = l;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;elem != x)</span><br><span class="line">    &#123;</span><br><span class="line">        s = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n, m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要删除的值m:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    deletelinklist(L, m);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14.试设计一个算法，将单链表中值最小的那个结点删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletelinklist</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist cur, curpre, <span class="built_in">min</span>, minpre;</span><br><span class="line">    <span class="comment">//cur:要删除节点的前面一个（遍历作用） curpre: 要删除节点的前面一个的前驱</span></span><br><span class="line">    <span class="comment">//min:最小值的节点                   minpre:最小值的节点的前驱</span></span><br><span class="line">    cur = <span class="built_in">min</span> = curpre = minpre = l;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;elem &lt; <span class="built_in">min</span>-&gt;elem)</span><br><span class="line">        &#123;</span><br><span class="line">            minpre = curpre;</span><br><span class="line">            <span class="built_in">min</span> = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        curpre = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    minpre-&gt;next = <span class="built_in">min</span>-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">min</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n, m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    deletelinklist(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15.试设计一个算法，将单链表中值最大的那个结点删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletelinklist</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist cur, curpre, <span class="built_in">max</span>, maxpre;</span><br><span class="line">    <span class="comment">//cur:要删除节点的前面一个（遍历作用） curpre: 要删除节点的前面一个的前驱</span></span><br><span class="line">    <span class="comment">//max:最大值的节点                   maxpre:最大值的节点的前驱</span></span><br><span class="line">    cur = <span class="built_in">max</span> = curpre = maxpre = l;</span><br><span class="line">    <span class="built_in">max</span>-&gt;elem = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur -&gt; elem &gt; <span class="built_in">max</span> -&gt; elem)</span><br><span class="line">        &#123;</span><br><span class="line">            maxpre = curpre;</span><br><span class="line">            <span class="built_in">max</span> = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        curpre = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    maxpre-&gt;next = <span class="built_in">max</span>-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">max</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    deletelinklist(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16.试设计一个算法，使得在一个有序的单链表中插入一个元素后仍然有序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.如果链表序列是递增的</span></span><br><span class="line">    Linklist p, s, q;</span><br><span class="line">    s = l;</span><br><span class="line">    p = s-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;elem &lt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        s = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    q-&gt;elem = x;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">    s -&gt;next = q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.如果链表序列是递减的</span></span><br><span class="line">    Linklist p, s, q;</span><br><span class="line">    s = l;</span><br><span class="line">    p = s-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;elem &gt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        s = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    q-&gt;elem = x;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">    s -&gt;next = q;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要插入的数值x:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    insertlinklist(L, x);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>class work</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇blog文章</title>
    <url>/2019/12/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="1-stack"><a href="#1-stack" class="headerlink" title="1.stack"></a>1.stack</h2>]]></content>
      <tags>
        <tag>new test</tag>
      </tags>
  </entry>
</search>
