<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>5.Smallest multiple</title>
    <url>/2020/02/12/5-Smallest-multiple/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>$2520$ is the smallest number that can be divided by each of the numbers from $1$ to $10$ without any remainder.</p>
<p>What is the smallest positive number that is <u>evenly divisible</u> by all of the numbers from $1$ to $20$?</p>
<p> <strong>evenly divisible</strong>:  divisible with no remainder</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ol>
<li><p>数学解法：</p>
<p>题意的意思让你求一个能被$1$ ~ $20$ 都能整除的一个整数。</p>
<p>我们最直接的想法就是去找$1$ ~ $20$ 的最小公倍数。</p>
<p>欧几里得算法求出即可</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a % b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    <span class="keyword">int</span> flag = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        flag = a[i] / gcd(a[i], flag) * flag;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考资料可参考:（有关于数论的基本问题）</p>
<ul>
<li><p><a href="https://blog.csdn.net/leimingfu/article/details/97244935" target="_blank" rel="noopener">https://blog.csdn.net/leimingfu/article/details/97244935</a></p>
</li>
<li><p><a href="https://blog.csdn.net/NJU_Flepped/article/details/76270241" target="_blank" rel="noopener">https://blog.csdn.net/NJU_Flepped/article/details/76270241</a></p>
</li>
</ul>
<ol>
<li><p>我们可以采用暴力的方案得出结果 因为数据量只有20 ，我们可以用对$i$ 和$j$ 遍历寻找一个$i$满足对$1$ ~$20$都满足整除方案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       IOS</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; ; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span> ; j &lt;= <span class="number">20</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">               <span class="keyword">if</span>(i % j != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                   flag = <span class="number">0</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//flag的判断放到i循环中</span></span><br><span class="line">           <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>在求解最小公倍数的时候,有定理：</p>
<script type="math/tex; mode=display">
x、y 两个数的最小公倍数乘以它们的最大公约数等于 x 和 y 本身的乘积</script><p>故存在公式:</p>
<script type="math/tex; mode=display">
LCM(x,y)=x/GCD(x,y)*b</script><p>但计算过程中不能写成：</p>
<script type="math/tex; mode=display">
LCM(x,y)=(x*y)/GCD(x,y)</script><p>会存在$x * y$的精度溢出。</p>
<p>打表程序如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a % b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    ll flag1 = a[<span class="number">1</span>];</span><br><span class="line">    ll flag2 = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag1 = (a[i] * flag1) / (gcd(a[i], flag1));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"#对flag1"</span> &lt;&lt; <span class="string">"-----"</span> &lt;&lt; i &lt;&lt; <span class="string">"####"</span> &lt;&lt; flag1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag2 = a[i] / gcd(a[i], flag2) * flag2;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"#对flag2"</span> &lt;&lt; <span class="string">"-----"</span> &lt;&lt; i &lt;&lt; <span class="string">"####"</span> &lt;&lt; flag2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n%lld\n"</span>,flag1, flag2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>我吐了….</strong></p>
<p>最后出现了精度溢出…</p>
<p>在 $flag * 20$的时候……</p>
<p><img src="/2020/02/12/5-Smallest-multiple/picture.PNG" alt></p>
</li>
</ol>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><script type="math/tex; mode=display">
Answer:    232792560</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3><div class="pdf" target="answer.pdf" height></div></li>
</ol>
]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>4.Largest palindrome product</title>
    <url>/2020/02/11/4-Largest-palindrome-product/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is $9009 = 91 × 99$.</p>
<p>Find the largest palindrome made from the product of two 3-digit numbers.</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>1.</p>
<p>题意就是让你找一个最大回文数 ，是由两个三位数乘积可得到的。</p>
<p>（这编程题嘛~）</p>
<p>我们这里采用了两个函数,一个是$itoa$函数， 另一个是$strrev$，两个都是非标准$C/C++$库中的函数。</p>
<ul>
<li><p>$itoa$：一个把整数转换成为字符串的函数。</p>
<p>在头文件$cstdlib$中 用法如下：</p>
<script type="math/tex; mode=display">
char *itoa (int value, char *str, int base )\\
返回一个转换后的字符串指针\\
value:要被转换的整数\\
str:转换后的字符串\\
base:转换的进制数</script></li>
<li><p>$strrev$：将字符串中的字符按照逆序进行反转。</p>
<p>在头文件$cstring$中，用法如下：</p>
<script type="math/tex; mode=display">
char *strrev(char *s)\\
返回逆转后的字符串指针\\
s:要逆序的字符串</script></li>
</ul>
<p><strong>注意</strong>：此处判断的时候 一定要遍历字符串判断 不然会出现$5675-&gt;5765$这种情况 ！</p>
<p>这样我们从999开始 对$i j$ 进行$i * j$判断是不是回文数，如果是最大的，输出即可</p>
<p>（我们这里用两个参数$ans$和$solve$保存一下，其中需要记录当前最大的回文数） </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//10000--998001</span></span><br><span class="line"><span class="keyword">int</span> ans, solve = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_palindrome_number</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">10</span>], str[<span class="number">10</span>];</span><br><span class="line">    itoa(x, str, <span class="number">10</span>);</span><br><span class="line">    itoa(x, temp, <span class="number">10</span>);</span><br><span class="line">    strrev(temp);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; temp &lt;&lt; endl &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp[i] != str[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">999</span>; i &gt;= <span class="number">100</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">999</span>; j &gt;= <span class="number">100</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = i * j;</span><br><span class="line">            <span class="keyword">if</span>(is_palindrome_number(ans) &amp;&amp; ans &gt; solve)</span><br><span class="line">            &#123;</span><br><span class="line">                solve = ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.</p>
<p>数学方法就是用取模去判断三位数是不是一样的</p>
<p>可参考:<a href="https://www.cnblogs.com/zhouyinhui/archive/2011/01/14/1935824.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhouyinhui/archive/2011/01/14/1935824.html</a></p>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><script type="math/tex; mode=display">
Answer:906609</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3>   <div class="pdf" target="answer.pdf" height></div>]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>3.Largest prime factor</title>
    <url>/2020/02/10/3-Largest-prime-factor/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>The prime factors of $13195$ are $5$,$7$,$13$ and $29$.</p>
<p>What is the largest prime factor of the number $600851475143$?</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ol>
<li><p>题意是找到$600851475143$的最大质因子</p>
<p>例如 ：45可以分解成</p>
<script type="math/tex; mode=display">
45 = 3 * 3 * 5</script><p>它的质因子就是3，5  即45的最大质因子就是5</p>
<p>我们可以将其表示为该过程:</p>
<ul>
<li><p>遍历自然数(从$2$开始)，若$n$能够被$k$整除，则重复整除它，直到不能除尽为止。</p>
<p>然后再用$k + 1$ 重复上述操作</p>
</li>
</ul>
<p>例如：$45$除以$2$整除不了 则$45$ 除以$3$ 得到$15$ $15$ 再除以$3$得到$5$，$5$除以$4$无法整除，则$5$除以$5$得到$1$ 则循环结束。 </p>
</li>
</ol>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//！long long表示 int会溢出</span></span><br><span class="line"><span class="keyword">const</span> ll ans = <span class="number">600851475143</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll factor = <span class="number">2</span>;<span class="comment">//从2开始除嘛~</span></span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % factor == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, factor);<span class="comment">//选取最后一个即可</span></span><br><span class="line">            n /= factor;</span><br><span class="line">        &#125;</span><br><span class="line">        factor++;</span><br><span class="line">        <span class="comment">//此处可以优化为:factor += (factor == 2 ? 1 : 2)</span></span><br><span class="line">        <span class="comment">//因为素数除了2之外都是奇数</span></span><br><span class="line">        <span class="comment">//也就是从2 -&gt; 3 时加1 其余时候都加2</span></span><br><span class="line">        <span class="comment">//补充:当factor的平方大于n时，必定只有n这一个因子。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    solve(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>数学解法：</p>
<p>我们可以考虑一个定理：</p>
<p><strong>算数基本定理：</strong></p>
<script type="math/tex; mode=display">
任何一个大于1的自然数N，如果N不为质数，那么N可以唯一分解成有限个质数的乘积\\
即：N = P_1 * P_2 *P_3 ......*P_n  (其中P_1 < P_2<P_3 ......<P_n)</script><p>根据题意我们可以知道我们要计算的就是$P_n$</p>
<p>我们首先找到 对于N来说的一个最小质数因子 即$P_1$，然后我们再对于$N$来说，去除$P_1$,依次往下。最后当$P_x = P_n$时，得到的$P_x$ 就是最大的质因子。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>//1e8 不能采用素数筛<br>const ll ANS = 600851475143;<br>ll isprime(ll x)<br>{<br>    for(ll i = 2; ; i++)<br>    {<br>        if(x % i == 0)<br>            return i;<br>    }<br>}<br>int main(void)<br>{<br>    IOS<br>    ll prime_number = ANS;<br>    ll min_prime_number = isprime(prime_number);<br>    while(min_prime_number != prime_number)<br>    {<br>        prime_number /= min_prime_number;<br>        min_prime_number = isprime(prime_number);<br>    }<br>    cout &lt;&lt; prime_number &lt;&lt; endl;<br>    return 0;<br>}<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   ### 注意点</span><br><span class="line"></span><br><span class="line">1. 不可以采用素数筛 会超时。</span><br><span class="line">2. 以下代码从3开始  某种程度来说 不够严谨 但求的时$P_n$故可得到正确结果。</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;C++</span><br><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1e8 不能采用素数筛</span><br><span class="line">const ll ANS &#x3D; 600851475143;</span><br><span class="line">ll isprime(ll x)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i &#x3D; 3; ; i +&#x3D; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(x % i &#x3D;&#x3D; 0)</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    IOS</span><br><span class="line">    ll prime_number &#x3D; ANS;</span><br><span class="line">    ll min_prime_number &#x3D; isprime(prime_number);</span><br><span class="line">    while(min_prime_number !&#x3D; prime_number)</span><br><span class="line">    &#123;</span><br><span class="line">        prime_number &#x2F;&#x3D; min_prime_number;</span><br><span class="line">        min_prime_number &#x3D; isprime(prime_number);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; prime_number &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><script type="math/tex; mode=display">
Answer:6857</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3>   <div class="pdf" target="answer.pdf" height></div>]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Rhythmical</tag>
      </tags>
  </entry>
  <entry>
    <title>2.Even Fibonacci numbers</title>
    <url>/2020/02/10/2-Even-Fibonacci-numbers/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>
<script type="math/tex; mode=display">
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</script><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ol>
<li><p>一开始想的是我们可以直接写出对于前400万项的Fibonacci数列。</p>
<p>然后判断每一项是否是偶数 再<strong>sum</strong>一下。 </p>
<script type="math/tex; mode=display">
Fibonacci(n) = Fibonacci(n- 1) + Fibonacci(n - 2)</script><p>时间复杂度：${O(2n)}$  </p>
<p>不过可以采用乘方优化达到${O(\log n + n)}$ 的复杂度</p>
<p>可参考：<a href="https://www.cnblogs.com/AlvinZH/p/7637094.html" target="_blank" rel="noopener">https://www.cnblogs.com/AlvinZH/p/7637094.html</a></p>
<p><strong>BUT</strong> ：这种做法在400w情况下仍然爆了。</p>
</li>
</ol>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4000000</span>;</span><br><span class="line">ll Fibonacci[maxn];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    Fibonacci[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    Fibonacci[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= maxn; i++)</span><br><span class="line">        Fibonacci[i] = Fibonacci[i - <span class="number">1</span>] + Fibonacci[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Fibonacci[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            ans += Fibonacci[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>数学解法：</p>
<p>我们观察到 ，题目中只是让求出Fibonacci数列的偶数项之和，我们能否找到一个关于Fibonacci数列偶数项前${n}$项和的递推公式~</p>
<p>观察题目中给的Fibonacci偶数项有：</p>
<script type="math/tex; mode=display">
2，5，8，34，144，610   ...</script><p>从第三项开始有：</p>
<script type="math/tex; mode=display">
34 = 4*8+2;\\
144 = 4*34 + 8;\\
610 = 4*144+ 34 ;</script><p>所以有以下公式(对Fibonacci偶数数列)：</p>
<script type="math/tex; mode=display">
Fibonacci_e(n) = Fibonacci_e(n - 1) * 4 +Fibonacci_e(n - 2)</script><p>时间复杂度：${O(\frac{n}{2})}$[减少了一半的运算量]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4000000</span>;</span><br><span class="line">   ll Fibonacci[maxn];</span><br><span class="line">   <span class="keyword">int</span> ans;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       IOS</span><br><span class="line">       Fibonacci[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">       Fibonacci[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= maxn; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               Fibonacci[i] = <span class="number">4</span> * Fibonacci[i - <span class="number">1</span>] + Fibonacci[i - <span class="number">2</span>];</span><br><span class="line">               <span class="keyword">if</span>(Fibonacci[i] &lt; maxn)</span><br><span class="line">                   ans += Fibonacci[i];</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>判断偶数和！不是偶数个数！一开始写出SB代码…WA了</p>
<p>读题意！！！</p>
</li>
</ol>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3></li>
</ol>
<script type="math/tex; mode=display">
   Answer:4613732</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3>   <div class="pdf" target="answer.pdf" height></div>
]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Rhythmical</tag>
      </tags>
  </entry>
  <entry>
    <title>1.Multiples of 3 and 5</title>
    <url>/2020/02/09/1-Multiples-of-3-and-5/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>
<p>Find the sum of all the multiples of 3 or 5 below 1000.</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ol>
<li><p>暴力解法：</p>
<p>遍历从1 - 1000 判断一下每一个数字是不是3/5的倍数 如果是的话 就sum一下 。</p>
<p>时间复杂度：${O(n)}$</p>
</li>
</ol>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span> || i % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>数学解法：</p>
<p>（对于1 - 20）</p>
<p>观察对于3的倍数有：3 5 9 12 15 18</p>
<p>​        对于5的倍数有:    5 15 20</p>
<p><strong>！！！发现了什么！！！   盲生你发现了华点</strong></p>
<ul>
<li>对3来说：是以3为首项3为等差的等差数列</li>
<li>对5来说：是以5为首项5为等差的等差数列</li>
<li>我们再去掉以15为首项15为等差的等差数列(因为计算了两遍~)</li>
</ul>
<p>我们设要求的和为$F$，n为等差数列的和为$sum(n)$<br>有以下公式：</p>
<script type="math/tex; mode=display">
F = sum(3) + sum(5) - sum(15)</script><p>等差数列求和公式有：$sum(n) =\frac {n  *  (n+1)} {2} $</p>
<p>时间复杂度：${O(1)}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS &#123;ios::sync_with_stdio(false);cin.tie(0);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1000</span> - <span class="number">1</span>;<span class="comment">//不是1000 是999</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = maxn / x;</span><br><span class="line">    <span class="keyword">int</span> a1 = x;</span><br><span class="line">    <span class="keyword">int</span> an = a1 + (temp - <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">return</span> (a1 + an) * temp / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">3</span>) + sum(<span class="number">5</span>) - sum(<span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>边界取值取不到1000 所以计算的时候要999 否则要在得出的结果- 1000。</li>
</ol>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><script type="math/tex; mode=display">
Answer:233168</script><h3 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h3><div class="pdf" target="answer.pdf" height></div>
</li>
</ol>
]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Build a blog</title>
    <url>/2020/02/06/Build-a-blog/</url>
    <content><![CDATA[<h3 id="这里展示的主要是一些在blog搭建初期的遇到问题以及解决措施"><a href="#这里展示的主要是一些在blog搭建初期的遇到问题以及解决措施" class="headerlink" title="这里展示的主要是一些在blog搭建初期的遇到问题以及解决措施"></a>这里展示的主要是一些在blog搭建初期的遇到问题以及解决措施</h3><p>我使用的是hexo的blog框架</p>
<p>采用的主题是next.</p>
<a id="more"></a>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>搭建初期：</p>
<ul>
<li><p>参考：</p>
<p><a href="https://www.bilibili.com/video/av44544186?from=search&amp;seid=2420425254997109895" target="_blank" rel="noopener">https://www.bilibili.com/video/av44544186?from=search&amp;seid=2420425254997109895</a></p>
</li>
</ul>
<p>添加插件遇到的问题：</p>
<ul>
<li><p>添加图片：</p>
<p><a href="https://blog.csdn.net/u010996565/article/details/89196612" target="_blank" rel="noopener">https://blog.csdn.net/u010996565/article/details/89196612</a></p>
<p><a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p>
<p><a href="https://blog.csdn.net/lwcxy966/article/details/91363965" target="_blank" rel="noopener">https://blog.csdn.net/lwcxy966/article/details/91363965</a></p>
</li>
<li><p>创建标签和分类：</p>
<p><a href="https://blog.csdn.net/winter_chen001/article/details/79719154" target="_blank" rel="noopener">https://blog.csdn.net/winter_chen001/article/details/79719154</a></p>
<p><a href="https://blog.csdn.net/weixin_33857230/article/details/91474562" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33857230/article/details/91474562</a></p>
<p><a href="https://blog.csdn.net/ganzhilin520/article/details/79047249" target="_blank" rel="noopener">https://blog.csdn.net/ganzhilin520/article/details/79047249</a></p>
<p><a href="https://blog.csdn.net/Wonz5130/article/details/84666519" target="_blank" rel="noopener">https://blog.csdn.net/Wonz5130/article/details/84666519</a></p>
<p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93644533" target="_blank" rel="noopener">https://blog.csdn.net/mqdxiaoxiao/article/details/93644533</a></p>
</li>
<li><p>创建个人页面：</p>
<p><a href="https://www.cnblogs.com/ztoz/p/5515475.html" target="_blank" rel="noopener">https://www.cnblogs.com/ztoz/p/5515475.html</a></p>
<p><a href="https://blog.csdn.net/csdjia11/article/details/91896116" target="_blank" rel="noopener">https://blog.csdn.net/csdjia11/article/details/91896116</a></p>
</li>
<li><p>添加评论系统：</p>
<p><a href="https://blog.csdn.net/blue_zy/article/details/79071414" target="_blank" rel="noopener">https://blog.csdn.net/blue_zy/article/details/79071414</a></p>
<p><a href="https://www.cnblogs.com/yyhh/p/11058985.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyhh/p/11058985.html</a></p>
</li>
<li><p>添加PDF插件：</p>
<p><a href="http://lingr7.coding.me/2019/10/02/theme-hexo-pdf%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-%E8%A7%A3%E5%86%B3hexo-pdf%E6%96%87%E4%BB%B6%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98.html" target="_blank" rel="noopener"><a href="http://lingr7.coding.me/2019/10/02/theme-hexo-pdf使用技巧-解决hexo-pdf文件显示不全的问题.html" target="_blank" rel="noopener">http://lingr7.coding.me/2019/10/02/theme-hexo-pdf%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-%E8%A7%A3%E5%86%B3hexo-pdf%E6%96%87%E4%BB%B6%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98.html</a></a></p>
<p><a href="https://blog.csdn.net/u010820857/article/details/82356974" target="_blank" rel="noopener">https://blog.csdn.net/u010820857/article/details/82356974</a></p>
<p><a href="https://jiap.me/tutorial/how-to-post-pdf-on-website/" target="_blank" rel="noopener">https://jiap.me/tutorial/how-to-post-pdf-on-website/</a></p>
</li>
<li><p>添加二次元人物：</p>
<p><a href="https://blog.csdn.net/dataiyangu/article/details/83021854" target="_blank" rel="noopener">https://blog.csdn.net/dataiyangu/article/details/83021854</a></p>
<p><a href="https://blog.csdn.net/u011054333/article/details/82718910" target="_blank" rel="noopener">https://blog.csdn.net/u011054333/article/details/82718910</a></p>
<p><a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">https://huaji8.top/post/live2d-plugin-2.0/</a></p>
<p><a href="https://techstay.github.io/my-static-blog/2018/09/15/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E6%B7%BB%E5%8A%A0%E5%8F%AF%E7%88%B1%E7%9A%84Live-2D%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener"><a href="https://techstay.github.io/my-static-blog/2018/09/15/在Hexo博客上添加可爱的Live-2D模型/" target="_blank" rel="noopener">https://techstay.github.io/my-static-blog/2018/09/15/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E6%B7%BB%E5%8A%A0%E5%8F%AF%E7%88%B1%E7%9A%84Live-2D%E6%A8%A1%E5%9E%8B/</a></a></p>
</li>
<li><p>添加站内搜索：</p>
<p><a href="https://www.cnblogs.com/fsong/p/11759136.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsong/p/11759136.html</a></p>
</li>
<li><p>出现域名问题：</p>
<p><a href="https://github.com/xCss/Valine/issues/72" target="_blank" rel="noopener">https://github.com/xCss/Valine/issues/72</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>列出联通集</title>
    <url>/2020/01/29/%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给一个无向图  N个顶点（0 ~ N-1） E条边  从第0个顶点开始DFS/BFS遍历这个无向图</p>
<p>按照编号递增的顺序访问邻接点.</p>
<blockquote>
<p><strong>题目链接</strong>:</p>
<p><a href="https://pintia.cn/problem-sets/15/problems/714" target="_blank" rel="noopener">https://pintia.cn/problem-sets/15/problems/714</a></p>
</blockquote>
<p><strong>数据范围</strong>:</p>
<p>0 &lt;= N &lt;= 10</p>
<p>E未知</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>无（基础BFS/DFS）</p>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug &#123;printf(<span class="meta-string">"AC!!!\n"</span>);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn];<span class="comment">//无向图</span></span><br><span class="line"><span class="keyword">int</span> vis[maxn];<span class="comment">//标记该点是否访问过</span></span><br><span class="line"><span class="keyword">int</span> N, E;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; N; i1++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i1] &amp;&amp; G[x][i1])</span><br><span class="line">            DFS(i1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="keyword">int</span> flag = q.front();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; N; i1++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i1] &amp;&amp; G[flag][i1])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i1] = <span class="number">1</span>;</span><br><span class="line">                q.push(i1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; E;</span><br><span class="line">    <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        G[a][b] = <span class="number">1</span>;</span><br><span class="line">        G[b][a] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//无向图建图细节</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="comment">//DFS</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])<span class="comment">//标记访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt;"第" &lt;&lt; i &lt;&lt;"个点的DFS搜索:" &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#123; "</span>;</span><br><span class="line">            DFS(i);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#125;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[i])<span class="comment">//标记访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt;"第" &lt;&lt; i &lt;&lt;"个点的BFS搜索:" &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#123; "</span>;</span><br><span class="line">            BFS(i);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#125;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">8 6</span></span><br><span class="line"><span class="comment">0 7</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment">2 0</span></span><br><span class="line"><span class="comment">4 1</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">&#123; 0 1 4 2 7 &#125;</span></span><br><span class="line"><span class="comment">&#123; 3 5 &#125;</span></span><br><span class="line"><span class="comment">&#123; 6 &#125;</span></span><br><span class="line"><span class="comment">&#123; 0 1 2 7 4 &#125;</span></span><br><span class="line"><span class="comment">&#123; 3 5 &#125;</span></span><br><span class="line"><span class="comment">&#123; 6 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><ol>
<li><p>第一次提交的时候，获得了WA。</p>
<p>然后输出各个环节的程序，发现在queue处并没有进行执行。</p>
<p>……</p>
<p>发现没有添加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br></pre></td></tr></table></figure>
<p>这一行代码。。。。。。</p>
<p>菜死了….BFS递归遍历完后要清空标记数组再DFS。。。。。。</p>
<p>找了好久…</p>
</li>
<li><p>输出样例细节点：注意空格的位置及其按序号排列的遍历顺序换行。</p>
</li>
<li><p>BFS写的不多 要多加练习。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>kuangbin搜索专题：<a href="https://vjudge.net/article/720" target="_blank" rel="noopener">https://vjudge.net/article/720</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>Graph Theory</tag>
        <tag>BFS&amp;DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>六度空间</title>
    <url>/2020/01/29/%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给一个图，有N个结点 M条边  然后找出每一个结点从当前结点开始  与该节点距离不超过6的结点数占结点总数N的百分比.</p>
<blockquote>
<p><strong>题目链接</strong>:</p>
<p><a href="https://pintia.cn/problem-sets/15/problems/715" target="_blank" rel="noopener">https://pintia.cn/problem-sets/15/problems/715</a></p>
</blockquote>
<p><strong>数据范围</strong>:</p>
<p>N: 1 &lt; N &lt; 1e3</p>
<p>M: &lt;= 33 *N</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br></pre></td></tr></table></figure>
<p><em>Output</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: 70.00%</span><br><span class="line">2: 80.00%</span><br><span class="line">3: 90.00%</span><br><span class="line">4: 100.00%</span><br><span class="line">5: 100.00%</span><br><span class="line">6: 100.00%</span><br><span class="line">7: 100.00%</span><br><span class="line">8: 90.00%</span><br><span class="line">9: 80.00%</span><br><span class="line">10: 70.00%</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>图论遍历搜索/计数问题 可采用DFS/BFS求解。</p>
<p>对于该题，把每一个结点的交际圈看成一层，与该节点相连的所有节点都做计数，并与该节点距离小于6的节点做计数。</p>
<p>BFS/DFS的选择：</p>
<p>每一个节点 计算与其联通的所有节点，BFS较好。</p>
<p><strong>BFS模板+计数</strong></p>
<p>初始的BFS模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "#:" &lt;&lt; x &lt;&lt; "  ";</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; G[x][i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对每一个节点进行BFS</li>
<li>BFS中累计访问的节点数目</li>
<li><strong>记录“层”数，只计算六层以内的节点数目（难点：如何记录层数）</strong></li>
</ul>
<p><strong>BFS的记录层数写法详解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解释几个变量的具体含义：</span></span><br><span class="line">G[maxn][maxn]:存图</span><br><span class="line">vis[maxn]:标记该点是否被探索过</span><br><span class="line">？想一下把vis的<span class="built_in">memset</span>放到BFS里？还是main里？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先计数：BFS返回Count来计数</span></span><br><span class="line">Count：计数距离小于<span class="number">6</span>的节点</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">int</span> Count = <span class="number">1</span>;</span><br><span class="line">    q.push(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; G[x][i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Count++;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//再记录层数：</span></span><br><span class="line"><span class="comment">//关键点：如何去记录这一层已经结束并标记该下一层？</span></span><br><span class="line"><span class="comment">//ans:标记层数，从当前层数开始 -&gt; 第六层结束</span></span><br><span class="line"><span class="comment">//last:记录当前层的最后一个节点</span></span><br><span class="line"><span class="comment">//tail:记录下一层的最后一个节点</span></span><br><span class="line">最初赋值 先令last = v;</span><br><span class="line">即当前last指向该节点，然后遍历节点，压缩进队列过程中，将最后一个赋值给tail</span><br><span class="line">然后如果不为空出队过程中，如果last = 出队的节点，对last 重新赋值（下一层最后一个节点-&gt;tail）</span><br><span class="line"><span class="keyword">int</span> BFS(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">int</span> Count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> last = x;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    q.push(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; G[x][i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Count++;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">                tail = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last == x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            last = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">6</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> N, E;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));<span class="comment">//?玄幻错误 放到这里就对...</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">int</span> Count = <span class="number">1</span>;<span class="comment">//计数，是否到达第六个结点</span></span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> last = x;<span class="comment">//记录每一层的最后一个结点</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    q.push(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "#:" &lt;&lt; flag &lt;&lt; "  ";</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; G[x][i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Count++;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">                tail = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last == x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            last = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">6</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; E;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        G[a][b] = G[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sovle = BFS(i);</span><br><span class="line">        <span class="keyword">double</span> output = sovle * <span class="number">100.0</span> / N;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %.2lf%%\n"</span>, i, output);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><ol>
<li>BFS/DFS选取可以看问题是要最近/最多/最远进行选择，一般路径最短问题DFS，路径条数问题BFS.</li>
<li>memset在进行初始化中，要看数据范围，在该题，若对G进行初始化，则会发生内存超限。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ol>
<li><a href="https://www.cnblogs.com/zengguoqiang/p/8429087.html" target="_blank" rel="noopener">https://www.cnblogs.com/zengguoqiang/p/8429087.html</a></li>
<li><a href="https://blog.csdn.net/Dream_Weave/article/details/80870033" target="_blank" rel="noopener">https://blog.csdn.net/Dream_Weave/article/details/80870033</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>Graph Theory</tag>
        <tag>BFS&amp;DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>堆中的路径</title>
    <url>/2020/01/20/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定n个数（无序），将n个数插入到一个小顶堆a[i]中，然后m个询问，给定一个下标x，打印a[x]到根节点的路径</p>
<blockquote>
<p><strong>题目链接</strong>:</p>
<p><a href="https://pintia.cn/problem-sets/15/problems/713" target="_blank" rel="noopener">https://pintia.cn/problem-sets/15/problems/713</a></p>
</blockquote>
<p><strong>数据范围</strong>:</p>
<p>N, M &lt;= 1000</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="大顶堆小顶堆"><a href="#大顶堆小顶堆" class="headerlink" title="大顶堆小顶堆"></a>大顶堆小顶堆</h3><ol>
<li><p>先根据序列的输入顺序构造出一颗<strong>完全二叉树</strong>（从1开始 用数组存储）</p>
</li>
<li><p>大顶堆：arr[i + 1] &gt;= arr[2i + 1] &amp;&amp; arr[i] &gt;= arr[2i + 2]</p>
<p>小顶堆：arr[i + 1] &lt;= arr[2i + 1] &amp;&amp; arr[i] &lt;= arr[2i + 2]</p>
</li>
<li><p>建立大顶堆小顶堆的过程 == 堆排序的过程</p>
<p><u>对结点来说</u>： <strong>上浮</strong>      <strong>下沉</strong> </p>
</li>
<li><p>堆中的路径：</p>
<p><img src="/2020/01/20/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/pictrue.png" alt></p>
</li>
</ol>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createminheap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">-10001</span>;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertminheap</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length++;</span><br><span class="line">    <span class="keyword">int</span> n1 = length;</span><br><span class="line">    <span class="keyword">while</span>(arr[n1 / <span class="number">2</span>] &gt; x)<span class="comment">//把X放于最后逐个与它的父节点进行比较，很巧妙！</span></span><br><span class="line">    &#123;</span><br><span class="line">        arr[n1] = arr[n1 / <span class="number">2</span>];</span><br><span class="line">        n1 /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小顶堆的上浮操作</span></span><br><span class="line">    arr[n1] = x;<span class="comment">//链到数组最后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    createminheap();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        insertminheap(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[temp]);</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp /= <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, arr[temp]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;<span class="comment">//格式注意~</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度:O(N * logN)</span></span><br></pre></td></tr></table></figure>
<h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><ol>
<li><p>小顶堆和大顶堆的定义及构建方法。</p>
</li>
<li><p>切入点不要去直接建立一个小顶堆  题意说明要插入，而不是去建立一个最小堆</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>1.堆排序：<a href="https://www.cnblogs.com/lanhaicode/p/10546257.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanhaicode/p/10546257.html</a></p>
<p>2.小顶堆的建立：<a href="https://blog.csdn.net/fdkNeverStopLearning/article/details/81662122" target="_blank" rel="noopener">https://blog.csdn.net/fdkNeverStopLearning/article/details/81662122</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>是否同一颗二叉搜索树</title>
    <url>/2020/01/15/%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定两个不同的二叉搜索树，N个数，L次询问判断，判断这两个二叉搜索树是否结构一样。</p>
<blockquote>
<p><strong>题目链接</strong>:</p>
<p><a href="https://pintia.cn/problem-sets/15/problems/712" target="_blank" rel="noopener">https://pintia.cn/problem-sets/15/problems/712</a></p>
</blockquote>
<p><strong>数据范围</strong>:<br>N &lt;= 10</p>
<p>L范围不确定</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong><em>二叉搜索树</em></strong></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>BST(Binary Search tree)，可能为空树，可能是一个具有以下性质的一颗树:</p>
<ul>
<li><p>[ ] 1. 若其左子树不为空，则左子树上所有的结点的值均小于它的根节点的值；</p>
</li>
<li><p>[ ] 2. 若其右子树不为空，则右子树上所有的结点的值均大于大的根节点的值；</p>
</li>
<li><p>[ ] 3. 它的左右子树也均为二叉搜索树。</p>
</li>
</ul>
<ul>
<li>[ ] 4. 无相同键值的结点。（有争议）</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>插入 查找复杂度较低。（相对于线性数据结构来说）</p>
<p>期望：$ {O(\log n)} $</p>
<p>当序列有序时，树退化成线性表</p>
<p>最坏：${O(n)}$</p>
<h4 id="支持操作"><a href="#支持操作" class="headerlink" title="支持操作"></a>支持操作</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><blockquote>
<p>在一个二叉搜索树T中，查找值为X的结点</p>
</blockquote>
<p>查找过程：<u><strong>递归</strong></u></p>
<p>0.若T为空树，则查找失败，否则。</p>
<p>1.若X等于T的根节点的键值，则查找成功，否则。</p>
<p>2.若X小于T的根节点的键值，则查找T的左子树，否则。</p>
<p>3.查找T的右子树。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, KeyType key, BiTree f, BiTree &amp;p)</span> </span>&#123;</span><br><span class="line"><span class="comment">//在搜索二叉树T中查询键值为key的元素，p指向key元素节点，f表示查找失败时，指向T的父亲，初始调用值为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!T) &#123; <span class="comment">// 查找不成功</span></span><br><span class="line">        p = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == T-&gt;data.key) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data.key) <span class="comment">// 在左子树中继续查找</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在右子树中继续查找</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>相关联系</strong>：</p>
<p>与此题相比，没有让你查找X的值的位置，判断两个二叉搜素树是否相同，即从根节点开始遍历树T，判断每一个结点及其左右孩子是否相同，反之，则树不相同。</p>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><blockquote>
<p>向一个二叉搜索树T中，插入一个键值为X的结点。（不要破坏原有的二叉搜索树的结构特点）</p>
</blockquote>
<p>插入过程：<u><strong>递归</strong></u></p>
<p>0.若T为空树，则X的结点作为根节点插入，否则。</p>
<p>1.若X等于T的根节点的键值，则返回，否则。</p>
<p>2.若X小于T的根节点的键值，则将X的结点插入到T的左子树中，否则。</p>
<p>3.把X插入到T的右子树中。</p>
<blockquote>
<p>注：新插入的结点总是叶子节点（想一下就出来了）</p>
</blockquote>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *&amp;T, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) &#123;</span><br><span class="line">        s = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        T = s; <span class="comment">// 被插结点S为新的根结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.key == T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 关键字等于e.key的数据元素，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (e.key &lt; T-&gt;data.key)</span><br><span class="line">        InsertBST(T-&gt;lchild, e);  <span class="comment">// 将 e 插入左子树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        InsertBST(T-&gt;rchild, e);  <span class="comment">// 将 e 插入右子树</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><blockquote>
<p>在一个二叉搜索树T中，删除一个键值为X的结点。（不要破坏原有的二叉搜索树的结构特点）</p>
</blockquote>
<p>删除过程：<u><strong>递归+旋转结点</strong></u></p>
<p>0.若X结点为叶子结点，只需要修改其双亲结点的指针。</p>
<p>1.若X有左孩子结点XL<strong>或</strong>右孩子结点XR，直接令XL/XR成为删除结点的左孩子结点/右孩子结点。</p>
<p>2.若X有左孩子结点XL<strong>和</strong>右孩子结点XR，有两种做法：（规定删除结点为X 其父节点为T）</p>
<ul>
<li>令XL为T的左/右子树结点（依据X是T的左/右子树），S是XL的最右下结点，而X的右子树为S的右子树。</li>
<li>令X的直接前驱/直接后驱替代T，再直接删除X的直接前驱/直接后驱。</li>
</ul>
<blockquote>
<p>基本思路：不要去删除X，而是选择X的有序的前驱结点或者有序的后驱结点来替代X。</p>
<p>参考资料：<a href="https://en.wikipedia.org/wiki/Binary_search_tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Binary_search_tree</a></p>
</blockquote>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T, KeyType key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若二叉查找树T中存在关键字等于key的数据元素时，则删除该数据元素，并返回</span></span><br><span class="line">    <span class="comment">// TRUE；否则返回FALSE</span></span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//不存在关键字等于key的数据元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == T-&gt;data.key)   <span class="comment">//   找到关键字等于key的数据元素</span></span><br><span class="line">            <span class="keyword">return</span> Delete(T);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data.key)</span><br><span class="line">            <span class="keyword">return</span> DeleteBST(T-&gt;lchild, key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> DeleteBST(T-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree *&amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该节点为叶子节点，直接删除</span></span><br><span class="line">    BiTree *q, *s;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;rchild &amp;&amp; !p-&gt;lchild) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = <span class="literal">NULL</span>;  <span class="comment">// Status Delete(BiTree *&amp;p) 要加&amp;才能使P指向NULL</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;rchild) &#123; <span class="comment">// 右子树空则只需重接它的左子树</span></span><br><span class="line">        q = p-&gt;lchild;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        p-&gt;data = p-&gt;lchild-&gt;data;</span></span><br><span class="line"><span class="comment">        p-&gt;lchild=p-&gt;lchild-&gt;lchild;</span></span><br><span class="line"><span class="comment">        p-&gt;rchild=p-&gt;lchild-&gt;rchild;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p-&gt;data = q-&gt;data;</span><br><span class="line">        p-&gt;lchild = q-&gt;lchild;</span><br><span class="line">        p-&gt;rchild = q-&gt;rchild;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;lchild) &#123; <span class="comment">// 左子树空只需重接它的右子树</span></span><br><span class="line">        q = p-&gt;rchild;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        p-&gt;data = p-&gt;rchild-&gt;data;</span></span><br><span class="line"><span class="comment">        p-&gt;lchild=p-&gt;rchild-&gt;lchild;</span></span><br><span class="line"><span class="comment">        p-&gt;rchild=p-&gt;rchild-&gt;rchild;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p-&gt;data = q-&gt;data;</span><br><span class="line">        p-&gt;lchild = q-&gt;lchild;</span><br><span class="line">        p-&gt;rchild = q-&gt;rchild;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左右子树均不空</span></span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span> (s-&gt;rchild) &#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125; <span class="comment">// 转左，然后向右到尽头</span></span><br><span class="line">        p-&gt;data = s-&gt;data;  <span class="comment">// s指向被删结点的“前驱”</span></span><br><span class="line">        <span class="keyword">if</span> (q != p)</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;  <span class="comment">// 重接*q的右子树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;  <span class="comment">// 重接*q的左子树</span></span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, L;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">binnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binnode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binnode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;binnode, *bintree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bintreeinsert</span><span class="params">(bintree &amp;Tree, bintree &amp;temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;data &gt;= Tree-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Tree-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            bintreeinsert(Tree-&gt;rchild, temp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Tree-&gt;rchild = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;data &lt; Tree-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Tree-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            bintreeinsert(Tree-&gt;lchild, temp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Tree-&gt;lchild = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createbintree</span><span class="params">(bintree &amp;T, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        bintree temp;</span><br><span class="line">        temp = (bintree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(binnode));</span><br><span class="line">        temp-&gt;data = x;</span><br><span class="line">        temp-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(T != <span class="literal">NULL</span>)<span class="comment">//第一次判断是否为空树</span></span><br><span class="line">            bintreeinsert(T, temp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_same_binsearchtree</span><span class="params">(bintree T1, bintree T2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((T1 != <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>) || (T1 == <span class="literal">NULL</span> &amp;&amp; T2 != <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((T1 != <span class="literal">NULL</span> &amp;&amp; T2 != <span class="literal">NULL</span>) &amp;&amp; (T1-&gt;data != T2-&gt;data))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (is_same_binsearchtree(T1-&gt;lchild, T2-&gt;lchild) &amp;&amp; is_same_binsearchtree(T1-&gt;rchild, T2-&gt;rchild));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Allfree</span><span class="params">(bintree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        Allfree(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        Allfree(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; L;</span><br><span class="line">        bintree T1, T2;</span><br><span class="line">        T1 = T2 = <span class="literal">NULL</span>;<span class="comment">//不加会报错！！！</span></span><br><span class="line">        createbintree(T1, N);</span><br><span class="line">        <span class="keyword">while</span>(L--)</span><br><span class="line">        &#123;</span><br><span class="line">            T2 = <span class="literal">NULL</span>;</span><br><span class="line">            createbintree(T2, N);</span><br><span class="line">            <span class="keyword">bool</span> flag = is_same_binsearchtree(T1, T2);</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            Allfree(T2);</span><br><span class="line">        &#125;</span><br><span class="line">        Allfree(T1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h3><ol>
<li>一定记得建完后释放内存（删除当前树）[否则回WA on test 2]</li>
<li>main函数中T1 T2 的初始化。（代码习惯问题）</li>
<li>建树过程中第一次插入中要特判T==NULL是否为空</li>
<li><strong>free函数是释放的单个结点，释放整个树要手写函数！</strong></li>
<li>递归判断时思路要清晰，左右子树递归下去一定是&amp;&amp;（因为要左右同时成立才满足true条件）。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>1.结构体定义中的细节问题：</p>
<p><a href="https://zhidao.baidu.com/question/274601639.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/274601639.html</a></p>
<p><a href="https://blog.csdn.net/hk121/article/details/80839063" target="_blank" rel="noopener">https://blog.csdn.net/hk121/article/details/80839063</a></p>
<p>2.《算法导论》对于BST的讲解：</p>
<p><a href="https://blog.csdn.net/csdn0123zl/article/details/81253648" target="_blank" rel="noopener">https://blog.csdn.net/csdn0123zl/article/details/81253648</a></p>
<p>3.BST的Wiki百科：</p>
<p><a href="https://zh.wikipedia.org/wiki/二叉搜索树" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91</a></p>
<p><a href="https://en.wikipedia.org/wiki/Binary_search_tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Binary_search_tree</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>树的同构</title>
    <url>/2020/01/14/%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给你两个相同结点个数的树,判断这两颗树是否同构。</p>
<blockquote>
<p><strong>题目链接</strong>:</p>
<p><a href="https://pintia.cn/problem-sets/15/problems/711" target="_blank" rel="noopener">https://pintia.cn/problem-sets/15/problems/711</a></p>
</blockquote>
<p><strong>数据范围</strong>:N &lt;= 10</p>
<p><strong>样例</strong>:</p>
<p><em>Input</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">A 1 2</span><br><span class="line">B 3 4</span><br><span class="line">C 5 -</span><br><span class="line">D - -</span><br><span class="line">E 6 -</span><br><span class="line">G 7 -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line">8</span><br><span class="line">G - 4</span><br><span class="line">B 7 6</span><br><span class="line">F - -</span><br><span class="line">A 5 1</span><br><span class="line">H - -</span><br><span class="line">C 0 -</span><br><span class="line">D - -</span><br><span class="line">E 2 -</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><u>同构</u>：</p>
<p><em>题目描述</em>：</p>
<p>两颗树A, B  若A能够通过若干次左右孩子的互换得到B，则称A B 两棵树同构。</p>
<p><em>离散数学描述</em>：</p>
<p>若两个树A, B 同构，当且仅当存在一个从A的结点到B的结点的  <strong>一对一</strong> 映上函数</p>
<p><strong><em>映上函数</em></strong>：<strong>从A到B的函数f称为映上的或满射的，当且仅当对每个b∈B，有元素a∈A使得f（a）=b。如果函数f是映上的，就说它是满射函数。</strong></p>
<p>即:A B为同构树，在A中，结点V和结点W相邻，则在B中，结点f(V)和结点f(W)也相邻。</p>
<p>一般对于多叉树而言,同构的判断就是计算出各个结点的度，并记录后，对可能同构的树做比较，若一一对应，则互为同构树。</p>
<p>此题目为二叉树  需要从题目描述的方式去考虑</p>
<p><strong>切入点</strong>：根节点</p>
<p>从根节点出发,依次按结点序号判断当前结点的左右子树是否相同  直到结点全部遍历完全 </p>
<p>思想：层序遍历  考虑按照<strong>结点-&gt;左子树-&gt;右子树</strong>即可  递归遍历</p>
<p><strong><em>树的遍历存储经典题目！！！</em></strong></p>
<h2 id="题目做法"><a href="#题目做法" class="headerlink" title="题目做法"></a>题目做法</h2><h3 id="存储树的结构"><a href="#存储树的结构" class="headerlink" title="存储树的结构"></a>存储树的结构</h3><p>N&lt;=10  可以直接结构体数组存储  结构体成员变量有三个：<strong>当前结点  左孩子结点  右孩子结点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bintree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;<span class="comment">//当前结点的存储字符</span></span><br><span class="line">    <span class="keyword">int</span> lchild;<span class="comment">//左孩子结点的序号</span></span><br><span class="line">    <span class="keyword">int</span> rchild;<span class="comment">//右孩子结点的序号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="寻找根节点"><a href="#寻找根节点" class="headerlink" title="寻找根节点"></a>寻找根节点</h3><p>采用一种边建树边标记的做法。</p>
<p><strong><em>根节点</em></strong>：该结点不作为子结点在其他子树中出现  所以我么只需要判断某一个结点是否在其他结点的左右孩子结点中出现即可。</p>
<p><strong><em>具体做法</em></strong>：</p>
<p>读入时，用一个vis数组存储当前结点是否存在孩子结点。首先初始化为0。</p>
<p>每次读入样例存储再遍历时，判断其左右孩子结点是否为 ‘<strong>-</strong>’ ，若不为空，则在结构体数组中存储元素的ch信息，并将vis数组中对于该节点的值标记为1。</p>
<p>最后遍历vis数组，<strong>按照结点的序号开始遍历</strong>，当vis为0时，该节点即为根节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(bintree T[])</span><span class="comment">//返回当前树的根节点序号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">-1</span>;<span class="comment">//代表根节点的编号</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> i1, i2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> vis[maxn];<span class="comment">//左右子树下标进行标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar();<span class="comment">//用scanf读入一定要加空格</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c %c %c"</span>, &amp;T[i].ch, &amp;i1, &amp;i2);</span><br><span class="line">            <span class="keyword">if</span>(i1 != <span class="string">'-'</span>)<span class="comment">//如果存在左孩子</span></span><br><span class="line">            &#123;</span><br><span class="line">                T[i].lchild = i1 - <span class="string">'0'</span>;</span><br><span class="line">                vis[T[i].lchild] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T[i].lchild = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i2 != <span class="string">'-'</span>)<span class="comment">//如果存在右孩子</span></span><br><span class="line">            &#123;</span><br><span class="line">                T[i].rchild = i2 - <span class="string">'0'</span>;</span><br><span class="line">                vis[T[i].rchild] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T[i].rchild = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                root = i;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//按照结点序号遍历  找到后就立即退出即可。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断两课树是否同构"><a href="#判断两课树是否同构" class="headerlink" title="判断两课树是否同构"></a>判断两课树是否同构</h3><ul>
<li>[ ] 递归写法判断</li>
</ul>
<h4 id="树空的情况"><a href="#树空的情况" class="headerlink" title="树空的情况"></a>树空的情况</h4><p>0.若两个树均为空树时，显然同构。</p>
<p>1.若一棵树为空，另一棵树不为空，则显然不同构。</p>
<h4 id="树不为空的情况"><a href="#树不为空的情况" class="headerlink" title="树不为空的情况"></a>树不为空的情况</h4><p>0.两棵树根节点的值不同，显然不同构。</p>
<p>1.两个树的根节点的值相等，则继续比较<strong><em>左左孩子和右右孩子</em></strong>。（若都同构，则树同构）</p>
<p>2.两个树的根节点的值相等，但<strong><em>左左孩子和右右孩子</em></strong>不同构，则继续比较<strong><em>左右孩子和右左孩子</em></strong>。（若都同构，则树同构）</p>
<p>3.两个树的根节点的值相等，但<strong><em>左左孩子和右右孩子</em></strong>不同构，而<strong><em>左右孩子和右左孩子</em></strong>亦不同构，则显然不同构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_isomorphic</span><span class="params">(<span class="keyword">int</span> tree1, <span class="keyword">int</span> tree2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree1 == <span class="number">-1</span> &amp;&amp; tree2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree1 == <span class="number">-1</span> &amp;&amp; tree2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree1 != <span class="number">-1</span> &amp;&amp; tree2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T1[tree1].ch != T2[tree2].ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((is_isomorphic(T1[tree1].lchild, T2[tree2].lchild) &amp;&amp; is_isomorphic(T1[tree1].rchild, T2[tree2].rchild)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((is_isomorphic(T1[tree1].lchild, T2[tree2].rchild) &amp;&amp; is_isomorphic(T1[tree1].rchild, T2[tree2].lchild)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结点"><a href="#总结点" class="headerlink" title="总结点"></a>总结点</h2><ul>
<li><p>[ ] 0. 样例递归建树中，getchar的插入位置(在不用cin读入的情况下)</p>
</li>
<li><p>[ ] 1. vis数组中找到第一个后，直接break。（因为是按照结点的序号来查找的）</p>
</li>
<li><p>[ ] 2. 对于该题来说，题目表明序号简便后，可以将结构体中的左右孩子定义成int类型不必采用传统的递归定义。</p>
</li>
<li><p>[ ] 4. 判断同构时，不要忘记空树的情况。（建树时可直接判断然后返回-1表示此树为空）</p>
</li>
</ul>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(ch,a,b) &#123;printf(<span class="meta-string">"Data: %c Lchild: %c Rchild: %c\n"</span>, ch, a, b);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bintree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> lchild;</span><br><span class="line">    <span class="keyword">int</span> rchild;</span><br><span class="line">&#125;T1[maxn], T2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(bintree T[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">-1</span>;<span class="comment">//代表根节点的编号</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> i1, i2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> vis[maxn];<span class="comment">//左右子树下标进行标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c %c %c"</span>, &amp;T[i].ch, &amp;i1, &amp;i2);</span><br><span class="line">            <span class="keyword">if</span>(i1 != <span class="string">'-'</span>)<span class="comment">//如果存在左孩子</span></span><br><span class="line">            &#123;</span><br><span class="line">                T[i].lchild = i1 - <span class="string">'0'</span>;</span><br><span class="line">                vis[T[i].lchild] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T[i].lchild = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i2 != <span class="string">'-'</span>)<span class="comment">//如果存在右孩子</span></span><br><span class="line">            &#123;</span><br><span class="line">                T[i].rchild = i2 - <span class="string">'0'</span>;</span><br><span class="line">                vis[T[i].rchild] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T[i].rchild = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                root = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_isomorphic</span><span class="params">(<span class="keyword">int</span> tree1, <span class="keyword">int</span> tree2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree1 == <span class="number">-1</span> &amp;&amp; tree2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree1 == <span class="number">-1</span> &amp;&amp; tree2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree1 != <span class="number">-1</span> &amp;&amp; tree2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T1[tree1].ch != T2[tree2].ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((is_isomorphic(T1[tree1].lchild, T2[tree2].lchild) &amp;&amp; is_isomorphic(T1[tree1].rchild, T2[tree2].rchild)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((is_isomorphic(T1[tree1].lchild, T2[tree2].rchild) &amp;&amp; is_isomorphic(T1[tree1].rchild, T2[tree2].lchild)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root1, root2;</span><br><span class="line">    root1 = build(T1);</span><br><span class="line">    root2 = build(T2);</span><br><span class="line">    <span class="comment">//printf("#1:%d\n#2:%d\n", root1, root2);</span></span><br><span class="line">    <span class="keyword">bool</span> flag = is_isomorphic(root1, root2);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "flag 的值:" &lt;&lt; flag &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（二）</title>
    <url>/2019/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C)/</url>
    <content><![CDATA[<p>17.编写一个算法，将带头结点的单向链表拆分成一个奇数链表和一个偶数链表，并分别输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitlinklist</span><span class="params">(Linklist &amp;l1, Linklist &amp;l2, Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l2 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    l3 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l1;</span><br><span class="line">    q = l2;</span><br><span class="line">    s = l3;</span><br><span class="line">    p = l1 -&gt; next;</span><br><span class="line">    q -&gt; next = s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;elem % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q -&gt; next = p;</span><br><span class="line">            <span class="comment">//printf("q的元素值:%d\n", q -&gt; elem);</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">            q -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;elem % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s -&gt; next = p;</span><br><span class="line">            <span class="comment">//printf("s的元素值:%d\n", s -&gt; elem);</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            s = s -&gt; next;</span><br><span class="line">            s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L1, L2, L3;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L1, n);</span><br><span class="line">    splitlinklist(L1, L2, L3);</span><br><span class="line">    outlinklist(L2);</span><br><span class="line">    outlinklist(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>18.已知一个带头结点的单链表lc={a1,b1,a2,b2….,an,bn}共２ｎ个元素，试设计一个算法将其拆分成二个带头结点的单向链表la 与lb,其中la={a1,a2,…an},lb={b1,b2,…,bn}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitlinklist</span><span class="params">(Linklist &amp;l1, Linklist &amp;l2, Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l2 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    l3 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l1;</span><br><span class="line">    q = l2;</span><br><span class="line">    s = l3;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = l1 -&gt; next;</span><br><span class="line">    q -&gt; next = s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//printf("%d\n", j);//j-1(j包含了头节点)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j - <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q -&gt; next = p;</span><br><span class="line">        <span class="comment">//printf("q的元素值:%d\n", q -&gt; elem);</span></span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        q = q -&gt; next;</span><br><span class="line">        q -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        s -&gt; next = p;</span><br><span class="line">        <span class="comment">//printf("s的元素值:%d\n", s -&gt; elem);</span></span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        s = s -&gt; next;</span><br><span class="line">        s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L1, L2, L3;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L1, n);</span><br><span class="line">    splitlinklist(L1, L2, L3);</span><br><span class="line">    outlinklist(L2);</span><br><span class="line">    outlinklist(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>19.已知二个带头结点的单向链表la 与lb,其中la={a1,a2,…an},lb={b1,b2,…,bn}， 试设计一个算法将其合并到一个带头结点的单链表lc中，且lc={a1,b1,a2,b2….,an,bn}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergerlinklist</span><span class="params">(Linklist &amp;l1, Linklist &amp;l2, Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l3 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l1-&gt;next;</span><br><span class="line">    q = l2-&gt;next;</span><br><span class="line">    s = l3;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        <span class="comment">//printf("%d ", s-&gt;elem);</span></span><br><span class="line">        s = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        s-&gt;next= q;</span><br><span class="line">        <span class="comment">//printf("%d ", s-&gt;elem);</span></span><br><span class="line">        s = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L1, L2, L3;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L1, n);</span><br><span class="line">    inlinklist(L2, n);</span><br><span class="line">    mergerlinklist(L1, L2, L3);</span><br><span class="line">    outlinklist(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20.已知单链表la={a1,a2,…an}，试编写一个算法，将la中的元素进行逆置，即la={an,an-1,…a1}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p ;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q-&gt;next = l-&gt;next;</span><br><span class="line">        l-&gt;next = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    transpose(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参考大佬解法:1.https://blog.csdn.net/v_xchen_v/article/details/53067448</span></span><br><span class="line"><span class="comment">//参考大佬解法:2.https://www.cnblogs.com/yepei/p/7120634.html</span></span><br></pre></td></tr></table></figure>
<p>21.试编写算法创建一个带头结点的单向循环链表la={a1,a2,…an}，并从指定的结点序号起输出循环链表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">special_traversal</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p;</span><br><span class="line">    p = l;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入指定的结点序号:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    special_traversal(L, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22.已知带头结点的单链表la={a1,a2,…an}，试编写一个算法将值重复的结点删除，使所得的结果表中的值均不相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_repeat</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;next-&gt;elem == p-&gt;elem)</span><br><span class="line">            &#123;</span><br><span class="line">                s = q-&gt;next;</span><br><span class="line">                q-&gt;next = s-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    delete_repeat(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>23.有一有序的单向链表（允许出现值相同的结点），试设计一个算法将值重复的结点删除，使所得的结果表中的值均不相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_order_repeat</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, q;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;elem == p-&gt;elem)</span><br><span class="line">        &#123;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    delete_order_repeat(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>24.已知一个带头结点的单链表lc中结点数据元素类型为字符型数据，主在包括二类字符（字母字符与数字字符），试设计一个算法，将lc拆分成二个链表la与lb，其中la的数据为字母字符，lb的数据为数字字符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"You Code AC!\n"</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitlinklist</span><span class="params">(Linklist &amp;l1, Linklist &amp;l2, Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l2 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    l3 = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l1;</span><br><span class="line">    q = l2;</span><br><span class="line">    s = l3;</span><br><span class="line">    p = l1 -&gt; next;</span><br><span class="line">    q -&gt; next = s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(((p-&gt;elem) &gt;= <span class="string">'a'</span> &amp;&amp; (p-&gt;elem) &lt;= <span class="string">'z'</span>)||((p-&gt;elem) &gt;= <span class="string">'A'</span> &amp;&amp; (p-&gt;elem) &lt;= <span class="string">'Z'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            q -&gt; next = p;</span><br><span class="line">            debug;</span><br><span class="line">            <span class="comment">//printf("q的元素值:%c\n", q -&gt; elem);</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">            q -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((p-&gt;elem) &gt;= <span class="string">'0'</span> &amp;&amp; (p-&gt;elem) &lt;= <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s -&gt; next = p;</span><br><span class="line">            <span class="comment">//printf("s的元素值:%c\n", s -&gt; elem);</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            s = s -&gt; next;</span><br><span class="line">            s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L1, L2, L3;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    inlinklist(L1, n);</span><br><span class="line">    splitlinklist(L1, L2, L3);</span><br><span class="line">    outlinklist(L2);</span><br><span class="line">    outlinklist(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>25.设单链表的前二个结点值为均为１，从第三个结点开始，结点值为前二个结点值之各，试设计一个具有ｎ（２５＞ｎ＞＝３）个结点的单向链表，并输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fibonacci_number</span><span class="params">(<span class="keyword">int</span> arr[maxn])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[<span class="number">1</span>] = arr[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;elem = arr[i+<span class="number">1</span>];</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    fibonacci_number(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>26.从键盘上输入一串括号组成的字符串，试编写一个算法，判断所输入的括号是否匹配，如匹配输出１否则输出０</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug1(x) &#123;printf(<span class="meta-string">"%c "</span>,x);&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug2 &#123;printf(<span class="meta-string">"You Code AC!\n"</span>);&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *base;</span><br><span class="line">    <span class="keyword">char</span> *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;sqstack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqstack</span><span class="params">(sqstack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.base = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(sqstack &amp;s, <span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top - s.base &gt;= maxn)</span><br><span class="line">    &#123;</span><br><span class="line">        s.base = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(s.base, (s.stacksize + maxn) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        s.top = s.base + s.stacksize;</span><br><span class="line">        s.stacksize += maxn;</span><br><span class="line">    &#125;</span><br><span class="line">    *s.top++ = ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">pop</span><span class="params">(sqstack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == s.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="comment">//printf("该栈已空\n");</span></span><br><span class="line">    <span class="keyword">return</span> *--s.top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">gettop</span><span class="params">(sqstack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == s.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="comment">//printf("该栈已空\n");</span></span><br><span class="line">    <span class="keyword">return</span> *(s.top<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(sqstack &amp;s, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    push(s,str[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> flag = gettop(s);</span><br><span class="line">        <span class="keyword">switch</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                <span class="keyword">if</span>(str[i] == <span class="string">')'</span>)</span><br><span class="line">                    pop(s);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    push(s, str[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">                <span class="keyword">if</span>(str[i] == <span class="string">']'</span>)</span><br><span class="line">                pop(s);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                push(s, str[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">                <span class="keyword">if</span>(str[i] == <span class="string">'('</span> || str[i] == <span class="string">']'</span>)</span><br><span class="line">                    push(s, str[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.base == s.top)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入字符串:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt;= strlen(str); i++)</span></span><br><span class="line">        <span class="comment">//debug1(str[i]);</span></span><br><span class="line">    createsqstack(s);</span><br><span class="line">    <span class="keyword">bool</span> conclusion = match(s, str);</span><br><span class="line">    <span class="keyword">if</span>(conclusion == <span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>27.从键盘上输入一个十进制数n，试编写一个算法，将其转换成对应的ｐ进制输出（ｐ为2.8.16）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *base;</span><br><span class="line">    <span class="keyword">int</span> *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;sqstack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqstack</span><span class="params">(sqstack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.base = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    s.top = s.base;</span><br><span class="line">    s.stacksize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(sqstack &amp;s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *s.top++ = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(sqstack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *--s.top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_stackempty</span><span class="params">(sqstack s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.base == s.top)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//代表栈为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//代表栈不为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">converison</span><span class="params">(sqstack &amp;s, <span class="keyword">int</span> n, <span class="keyword">int</span> base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        push(s, n % base);</span><br><span class="line">        n /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!is_stackempty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = pop(s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sqstack s;</span><br><span class="line">    createsqstack(s);</span><br><span class="line">    <span class="keyword">int</span> n, base;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入你要转换的数字和进制数:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;base);</span><br><span class="line">    converison(s, n, base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>28.从键盘上输入二个定长串s1与s2，试编写一个算法判断s1是否是s2的子串，如果是则输出１否则输出０</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> SString[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createstring</span><span class="params">(SString s, <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s[<span class="number">0</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = str[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printstring</span><span class="params">(SString s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s[<span class="number">0</span>]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>,s[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SString_match</span><span class="params">(SString s1, SString s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    i = j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= s1[<span class="number">0</span>] &amp;&amp; j &lt;= s2[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i] == s2[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; s2[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[maxn], str2[maxn];</span><br><span class="line">    SString s1, s2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请创建第一个定长串s1:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str1);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请创建第二个定长串s2:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str2);</span><br><span class="line">    createstring(s1, str1);</span><br><span class="line">    createstring(s2, str2);</span><br><span class="line">    <span class="comment">//printstring(s1);</span></span><br><span class="line">    <span class="comment">//printstring(s2);</span></span><br><span class="line">    <span class="keyword">bool</span> is_SString_match = SString_match(s1, s2);</span><br><span class="line">    <span class="keyword">if</span>(is_SString_match)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30.假设二叉树采用二叉链表存储结构，试设计一个算法求二叉树的叶子结点数并输出所有的叶子结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;binnode, *bintree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatbintree</span><span class="params">(bintree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch ==<span class="string">'#'</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (bintree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bintree));</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        creatbintree(T-&gt;lchild);</span><br><span class="line">        creatbintree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(bintree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        LNR(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>,T-&gt;data);</span><br><span class="line">        LNR(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leaf_node</span><span class="params">(bintree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild ==  <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        ans++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        leaf_node(T-&gt;lchild);</span><br><span class="line">        leaf_node(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    bintree T;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入二叉树的节点数目:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    creatbintree(T);</span><br><span class="line">    leaf_node(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"叶子结点数目:%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>31.假设二叉树采用二叉链表存储结构，试设计一个算法求二叉树的高度并给出指定结点的所在的层数（高度）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;binnode, *bintree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatbintree</span><span class="params">(bintree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch ==<span class="string">'#'</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (bintree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bintree));</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        creatbintree(T-&gt;lchild);</span><br><span class="line">        creatbintree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(bintree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        LNR(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>,T-&gt;data);</span><br><span class="line">        LNR(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(bintree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, <span class="built_in">max</span>;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">height</span>(T-&gt;lchild);</span><br><span class="line">        b = <span class="built_in">height</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">max</span> = a &gt; b ? a : b;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">max</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">finddeep</span><span class="params">(bintree T, <span class="keyword">char</span> s, <span class="keyword">int</span> ans,<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;data = s)</span><br><span class="line">        &#123;</span><br><span class="line">            x = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        finddeep(T-&gt;lchild, s, ans, x);</span><br><span class="line">        finddeep(T-&gt;rchild, s, ans, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> s;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    bintree T;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入二叉树的节点数目:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    creatbintree(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树的高度:%d\n"</span>,<span class="built_in">height</span>(T));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"AC!!!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入结点值:\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;s);</span><br><span class="line">    finddeep(T, s,<span class="number">0</span>,x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"结点值的:%d\n"</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>class work</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（一）</title>
    <url>/2019/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)/</url>
    <content><![CDATA[<p>1.已知顺序表L的长度为n，试编写算法实现在顺序表中删除值为elem的数据元素（其中n与elem从键盘输入）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + l.length; p++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletesqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; l.length &amp;&amp; l.arr[i] != elem)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; l.length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l.arr[j] != elem)</span><br><span class="line">        &#123;</span><br><span class="line">            l.arr[i++] = l.arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, elem;</span><br><span class="line">    sqlist L;</span><br><span class="line">    createsqlist(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n个元素:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    insqlist(L, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入删除的元素值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;elem);</span><br><span class="line">    deletesqlist(L, elem);</span><br><span class="line">    outsqlist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2.已知顺序表L长度为n，试编写算法实现在顺序表中值为elem的数据元素的后面插入一个值为key的数据元素（其中n、elem与key从键盘输入且顺序表的数据元素的值互不相同）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + l.length; p++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertsqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> elem, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + l.length; p++)</span><br><span class="line">        <span class="keyword">if</span>(*p == elem)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = p - l.arr;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr + l.length; p &gt;= l.arr + flag + <span class="number">1</span>; p--)</span><br><span class="line">        *(p + <span class="number">1</span>) = *p;</span><br><span class="line">    l.arr[flag + <span class="number">1</span>] = key;</span><br><span class="line">    l.length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, elem, key;</span><br><span class="line">    sqlist L;</span><br><span class="line">    createsqlist(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n个元素:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    insqlist(L, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要插入后边的元素的值和插入的元素值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;elem, &amp;key);</span><br><span class="line">    insertsqlist(L, elem, key);</span><br><span class="line">    outsqlist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.已知顺序表{a0,a1,a2,…,an-1}，且每个元素都是不相同的,试设计一个算法把所有的奇数移到所有的偶数的前面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(p = l.arr; p &lt; l.arr + l.length; p++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *i = l.arr;</span><br><span class="line">    <span class="keyword">int</span> *j = l.arr + l.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((*i) % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">//偶数</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span>((*j) % <span class="number">2</span> == <span class="number">1</span>)<span class="comment">//奇数</span></span><br><span class="line">            j--;</span><br><span class="line">        <span class="comment">//printf("%d  %d",*i, *j);</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    sqlist L;</span><br><span class="line">    createsqlist(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n个元素:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    insqlist(L, n);</span><br><span class="line">    change(L);</span><br><span class="line">    outsqlist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.已知二个集合la与lb,采用顺序结构存储，其中la={a1,a2,…an},lb={b1,b2,…,bｍ}， 试设计一个算法将其合并到一个顺序表lc中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l.arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, l.arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merger</span><span class="params">(sqlist &amp;l1, sqlist &amp;l2, sqlist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1.length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l3.arr[i] = l1.arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l3.length = l1.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l2.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l3.arr[i + l1.length] = l2.arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l3.length += l2.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    sqlist  L1, L2, L3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n和m的值来创建两个顺序表:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    createsqlist(L1);</span><br><span class="line">    createsqlist(L2);</span><br><span class="line">    createsqlist(L3);</span><br><span class="line">    insqlist(L1, n);</span><br><span class="line">    insqlist(L2, m);</span><br><span class="line">    merger(L1, L2, L3);</span><br><span class="line">    outsqlist(L3);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.已知一个顺序表la，其中la={a1,a2,…an}， 试设计一个算法将其从小到大进行排序 ，再输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l.arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, l.arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l.length - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l.arr[j] &gt; l.arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//int temp = l.arr[j];</span></span><br><span class="line">                <span class="comment">//l.arr[j] = l.arr[j + 1];</span></span><br><span class="line">                <span class="comment">//l.arr[j + 1] = temp;</span></span><br><span class="line">                swap(l.arr[j], l.arr[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    sqlist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    createsqlist(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n的值来创建一个顺序表:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    insqlist(L, n);</span><br><span class="line">    sortsqlist(L);</span><br><span class="line">    outsqlist(L);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.已知二个顺序la与lb，其中la={a1,a2,…an}，lb={b1,b2,…bm}， 试设计一个算法将它们合并到顺序表lc中，且lc仍然有序，再输出 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createsqlist</span><span class="params">(sqlist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l.arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxn * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    l.length = <span class="number">0</span>;</span><br><span class="line">    l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insqlist</span><span class="params">(sqlist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入数字来创建顺序表:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l.arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表的元素为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, l.arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merger</span><span class="params">(sqlist &amp;l1, sqlist &amp;l2, sqlist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1.length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l3.arr[i] = l1.arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l3.length = l1.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l2.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l3.arr[i + l1.length] = l2.arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l3.length += l2.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortsqlist</span><span class="params">(sqlist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l.length - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l.arr[j] &gt; l.arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//int temp = l.arr[j];</span></span><br><span class="line">                <span class="comment">//l.arr[j] = l.arr[j + 1];</span></span><br><span class="line">                <span class="comment">//l.arr[j + 1] = temp;</span></span><br><span class="line">                swap(l.arr[j], l.arr[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    sqlist  L1, L2, L3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入n和m的值来创建两个顺序表:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    createsqlist(L1);</span><br><span class="line">    createsqlist(L2);</span><br><span class="line">    createsqlist(L3);</span><br><span class="line">    insqlist(L1, n);</span><br><span class="line">    insqlist(L2, m);</span><br><span class="line">    merger(L1, L2, L3);</span><br><span class="line">    sortsqlist(L3);</span><br><span class="line">    outsqlist(L3);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.设计一个算法，以先进先出的方式创建一个带头结点的单向链表，并输出 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.设计一个算法，以后进先出的方式创建一个带头结点的单向链表，并输出 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Linklist  p;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        p-&gt;next = l-&gt;next;</span><br><span class="line">        l-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9.设计一个算法，以先进先出的方式创建一个带头结点的双向链表，并输出 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist  p, s;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    l -&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    s = l;</span><br><span class="line">    p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        p-&gt;prior = s;</span><br><span class="line">        s = p;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10.设计一个算法，以后进先出的方式创建一个带头结点的双向链表，并输出 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist  p;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    l -&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">    p-&gt;next = l-&gt;next;</span><br><span class="line">    l-&gt;next = p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        p -&gt; next = l -&gt; next;</span><br><span class="line">        l -&gt; next -&gt; prior = p;</span><br><span class="line">        l -&gt; next = p;</span><br><span class="line">        p -&gt; prior = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11.已知一个(head)单链表la，其中la={a1,a2,…an}， 试设计一个算法将其中从小到大进行排序 ，再输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortlinklist</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, s;<span class="comment">//记录i 跟踪</span></span><br><span class="line">    s = p = l-&gt;next;</span><br><span class="line">    <span class="comment">//p = l-&gt;next;</span></span><br><span class="line">    <span class="comment">//s = l-&gt;next;</span></span><br><span class="line">    <span class="keyword">while</span>(s)<span class="comment">//表示前边的节点i</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = s;</span><br><span class="line">        <span class="keyword">while</span>(p)<span class="comment">//表示后边的节点i + 1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s-&gt;elem &gt; p-&gt;elem)</span><br><span class="line">                swap(s-&gt;elem,p-&gt;elem);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    sortlinklist(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>12.已知二个单链表有序链表la与lb，其中la={a1,a2,…an}，lb={b1,b2,…bm}， 试设计一个算法将它们合并到单链表lc中，且lc仍然有序，再输出 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Linklist &amp;a, Linklist &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;next = a;</span><br><span class="line">    s = a;</span><br><span class="line">    a = a-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergerlinklist</span><span class="params">(Linklist &amp;l1, Linklist &amp;l2, Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, q, s;</span><br><span class="line">    p = l1-&gt;next;</span><br><span class="line">    q = l2-&gt;next;</span><br><span class="line">    l3 = s = l1;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;elem &lt; q-&gt;elem)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//s-&gt;next = p;</span></span><br><span class="line">            <span class="comment">//s = p;</span></span><br><span class="line">            <span class="comment">//p = p-&gt;next;</span></span><br><span class="line">            swap(p,s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//s-&gt;next = q;</span></span><br><span class="line">            <span class="comment">//s = q;</span></span><br><span class="line">            <span class="comment">//q = q-&gt;next;</span></span><br><span class="line">            swap(q,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p ? p : q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L1, L2, L3;</span><br><span class="line">    <span class="keyword">int</span>  n, m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L1, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建m个元素的链表的m值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    inlinklist(L2, m);</span><br><span class="line">    mergerlinklist(L1, L2, L3);</span><br><span class="line">    outlinklist(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>13.设计一个算法实现在带头结点的单向链表中删除给定值的结点。（链表中的数据元素值均不相同）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletelinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist p, s;</span><br><span class="line">    <span class="comment">//p = l;</span></span><br><span class="line">    <span class="comment">//s = l; 若没有 则无法删除链表第一个元素</span></span><br><span class="line">    p = s = l;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;elem != x)</span><br><span class="line">    &#123;</span><br><span class="line">        s = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n, m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要删除的值m:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    deletelinklist(L, m);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14.试设计一个算法，将单链表中值最小的那个结点删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletelinklist</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist cur, curpre, <span class="built_in">min</span>, minpre;</span><br><span class="line">    <span class="comment">//cur:要删除节点的前面一个（遍历作用） curpre: 要删除节点的前面一个的前驱</span></span><br><span class="line">    <span class="comment">//min:最小值的节点                   minpre:最小值的节点的前驱</span></span><br><span class="line">    cur = <span class="built_in">min</span> = curpre = minpre = l;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;elem &lt; <span class="built_in">min</span>-&gt;elem)</span><br><span class="line">        &#123;</span><br><span class="line">            minpre = curpre;</span><br><span class="line">            <span class="built_in">min</span> = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        curpre = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    minpre-&gt;next = <span class="built_in">min</span>-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">min</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist  L;</span><br><span class="line">    <span class="keyword">int</span>  n, m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    deletelinklist(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15.试设计一个算法，将单链表中值最大的那个结点删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletelinklist</span><span class="params">(Linklist &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist cur, curpre, <span class="built_in">max</span>, maxpre;</span><br><span class="line">    <span class="comment">//cur:要删除节点的前面一个（遍历作用） curpre: 要删除节点的前面一个的前驱</span></span><br><span class="line">    <span class="comment">//max:最大值的节点                   maxpre:最大值的节点的前驱</span></span><br><span class="line">    cur = <span class="built_in">max</span> = curpre = maxpre = l;</span><br><span class="line">    <span class="built_in">max</span>-&gt;elem = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur -&gt; elem &gt; <span class="built_in">max</span> -&gt; elem)</span><br><span class="line">        &#123;</span><br><span class="line">            maxpre = curpre;</span><br><span class="line">            <span class="built_in">max</span> = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        curpre = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    maxpre-&gt;next = <span class="built_in">max</span>-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">max</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    deletelinklist(L);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16.试设计一个算法，使得在一个有序的单链表中插入一个元素后仍然有序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Linklist p, END;<span class="comment">//定义尾部节点</span></span><br><span class="line">    END = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入想要创建的链表元素:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outlinklist</span><span class="params">(Linklist l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表中的值为:\n"</span>);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertlinklist</span><span class="params">(Linklist &amp;l, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.如果链表序列是递增的</span></span><br><span class="line">    Linklist p, s, q;</span><br><span class="line">    s = l;</span><br><span class="line">    p = s-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;elem &lt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        s = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    q-&gt;elem = x;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">    s -&gt;next = q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.如果链表序列是递减的</span></span><br><span class="line">    Linklist p, s, q;</span><br><span class="line">    s = l;</span><br><span class="line">    p = s-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;elem &gt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        s = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">    q-&gt;elem = x;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">    s -&gt;next = q;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    Linklist L;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入创建n个元素的链表的n值:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    inlinklist(L, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要插入的数值x:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    insertlinklist(L, x);</span><br><span class="line">    outlinklist(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>class work</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇blog文章</title>
    <url>/2019/12/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="1-stack"><a href="#1-stack" class="headerlink" title="1.stack"></a>1.stack</h2>]]></content>
      <tags>
        <tag>new test</tag>
      </tags>
  </entry>
</search>
